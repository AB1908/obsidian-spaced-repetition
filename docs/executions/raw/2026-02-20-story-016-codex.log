Script started on 2026-02-20 19:32:28-08:00 [COMMAND="codex exec --cd .worktrees/feat-story-016-named-categories --dangerously-bypass-approvals-and-sandbox $'You are delegated to execute one scoped task autonomously in this repository.\n\nExecution contract:\n- Work only on branch: feat/story-016-named-categories\n- Worktree path: .worktrees/feat-story-016-named-categories\n- Follow the scope document exactly: docs/plans/STORY-016-named-categories-settings-config.md\n- Follow the test contract exactly: docs/plans/STORY-016-test-contract.md\n- Use strict TDD: make tests fail first, then implement, then verify green.\n- Run required verification commands listed in the scope document.\n- Commit only when acceptance criteria are met.\n- Do not push, do not open PR, do not perform destructive git operations.\n- Final output must include: changed files, tests run, and any deviations from scope.\n\nScope document contents:\n# Plan: STORY-016 — Named Categories with Settings Config\n\n**Story:** `docs/stories/STORY-016-customizable-annotation-categories.md`  \n**Status:** Draft for execution\n\n## Goal\nReplace hardcoded numeric categories (`0..5`) with settings-driven named categories (`string`) and keep filtering/editor behavior consistent across import and card-creation flows.\n\n## Scope Boundaries\n\n### In Scope\n- Category domain type and defaults in settings.\n- Metadata serialization/deserialization for string category names.\n- Import editor category selection using configured categories.\n- Category filter UI and filtering predicates using string categories.\n- Tests covering new behavior and backward-compat for old numeric metadata values.\n\n### Out of Scope (for this story)\n- Category rename migration utility (tracked by STORY-021).\n- Icon picker UI beyond default icon for new categories.\n- Broader card-creation visibility redesign (tracked by STORY-017).\n\n## Planned Touchpoints\n- `src/config/annotation-categories.ts`\n- `src/settings.ts`\n- `src/data/models/annotations.ts`\n- `src/data/utils/metadataSerializer.ts`\n- `src/ui/routes/import/personal-note.tsx`\n- `src/ui/routes/import/useAnnotationEditor.ts`\n- `src/ui/components/category-filter.tsx`\n- `src/utils/annotation-filters.ts`\n- `tests/routes/import/PersonalNotePage.test.tsx`\n- `tests/routes/books/book/annotation/AnnotationListPage.test.tsx`\n- `tests/api.test.ts`\n- `tests/models/annotations.test.ts`\n- `tests/annotations.test.ts`\n- `tests/metadataSerializer.test.ts`\n\n## Incremental Execution Strategy\n\n### Phase A: Domain + Serialization\n1. Introduce `CategoryConfig` and default categories (`name`, `icon`) in settings/config.\n2. Change annotation category type from `number` to `string` at domain edges.\n3. Update metadata serializer/parser:\n- write `category: <name>`\n- parse strings\n- treat numeric legacy values as uncategorized (`undefined`) for compatibility\n\n### Phase B: UI + Filter Integration\n1. Render import category buttons from settings instead of hardcoded array.\n2. Add "add category" affordance with validated category name creation.\n3. Update editor hook and filter components/types to use `string | null`.\n4. Update `annotation-filters.ts` to compare category names (string equality).\n\n### Phase C: Test and Regression Hardening\n1. Update existing tests for string categories.\n2. Add regression tests for:\n- legacy numeric metadata deserialization fallback\n- settings-driven category rendering\n- category filter behavior with string categories\n3. Re-run full suite and update snapshots only where behavior intentionally changed.\n\n## Proposed Commit Topology\n1. `test(story-016): add string-category contracts and legacy fallback coverage`  \n2. `refactor(domain): switch category model and metadata serialization to string names`  \n3. `feat(ui): drive category controls from settings and support category creation`  \n4. `test(story-016): update snapshots and integration assertions for settings categories`  \n5. `docs(story-016): update story checklist and execution notes`\n\n## Parallelization Plan (Worktrees)\n- Lane 1 (Domain): Phase A core typing + serializer changes.\n- Lane 2 (UI): Phase B component/hook/settings plumbing.\n- Lane 3 (Tests): Phase C assertions/snapshots based on merged behavior.\n\nNote:\n- Lane 2 depends partially on Lane 1 types; run Lane 1 first or rebase Lane 2 after Lane 1 merge.\n- Lane 3 should run after Lane 1+2 to avoid churn.\n\n## Verification Gates\n1. `scripts/story-catalog.sh check`\n2. `scripts/lint-docs.sh`\n3. Targeted test pass:\n- `npm test -- --runInBand tests/metadataSerializer.test.ts`\n- `npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx`\n- `npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx`\n4. Full test suite:\n- `npm test -- --runInBand`\n5. Build:\n- `OBSIDIAN_PLUGIN_DIR=. npm run build`\n\n## Risks and Mitigations\n- Risk: broad type migration breaks unrelated tests.\n  - Mitigation: land domain/type changes first with targeted compatibility tests.\n- Risk: snapshot churn masks regressions.\n  - Mitigation: isolate snapshot commit and review it explicitly before merge.\n- Risk: settings-driven categories diverge between import and card-creation routes.\n  - Mitigation: assert both routes via integration tests and shared filter utility tests.\n\n\nTest contract contents:\n# Test Contract: STORY-016 Named Categories\n\n**Story:** `docs/stories/STORY-016-customizable-annotation-categories.md`  \n**Implementation Plan:** `docs/plans/STORY-016-named-categories-settings-config.md`  \n**Mode:** Contract-first with green commits (no red commit required due pre-commit gates)\n\n## Required Test Files\nTEST_FILE: tests/metadataSerializer.test.ts\nTEST_FILE: tests/models/annotations.test.ts\nTEST_FILE: tests/routes/import/PersonalNotePage.test.tsx\nTEST_FILE: tests/routes/books/book/annotation/AnnotationListPage.test.tsx\nTEST_FILE: tests/api.test.ts\n\n## Required Test Names\nTEST_NAME: serializes string category names in metadata\nTEST_NAME: ignores legacy numeric category metadata values\nTEST_NAME: category buttons render from configured settings categories\nTEST_NAME: selecting category saves category name string\nTEST_NAME: MoonReader card creation category filter uses string categories\n\n## Required Verification Commands\nTEST_CMD: npm test -- --runInBand tests/metadataSerializer.test.ts\nTEST_CMD: npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx\nTEST_CMD: npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx\nTEST_CMD: npm test -- --runInBand\nTEST_CMD: OBSIDIAN_PLUGIN_DIR=. npm run build\n\n## Notes\n- This contract is enforced by `scripts/verify-test-contract.sh`.\n- Delegated runs should pass this contract before handing control back for review.' " <not executed on terminal>]
OpenAI Codex v0.104.0 (research preview)
--------
workdir: /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
session id: 019c7e41-828e-7b92-bd59-d11076e7cd44
--------
user
You are delegated to execute one scoped task autonomously in this repository.

Execution contract:
- Work only on branch: feat/story-016-named-categories
- Worktree path: .worktrees/feat-story-016-named-categories
- Follow the scope document exactly: docs/plans/STORY-016-named-categories-settings-config.md
- Follow the test contract exactly: docs/plans/STORY-016-test-contract.md
- Use strict TDD: make tests fail first, then implement, then verify green.
- Run required verification commands listed in the scope document.
- Commit only when acceptance criteria are met.
- Do not push, do not open PR, do not perform destructive git operations.
- Final output must include: changed files, tests run, and any deviations from scope.

Scope document contents:
# Plan: STORY-016 — Named Categories with Settings Config

**Story:** `docs/stories/STORY-016-customizable-annotation-categories.md`  
**Status:** Draft for execution

## Goal
Replace hardcoded numeric categories (`0..5`) with settings-driven named categories (`string`) and keep filtering/editor behavior consistent across import and card-creation flows.

## Scope Boundaries

### In Scope
- Category domain type and defaults in settings.
- Metadata serialization/deserialization for string category names.
- Import editor category selection using configured categories.
- Category filter UI and filtering predicates using string categories.
- Tests covering new behavior and backward-compat for old numeric metadata values.

### Out of Scope (for this story)
- Category rename migration utility (tracked by STORY-021).
- Icon picker UI beyond default icon for new categories.
- Broader card-creation visibility redesign (tracked by STORY-017).

## Planned Touchpoints
- `src/config/annotation-categories.ts`
- `src/settings.ts`
- `src/data/models/annotations.ts`
- `src/data/utils/metadataSerializer.ts`
- `src/ui/routes/import/personal-note.tsx`
- `src/ui/routes/import/useAnnotationEditor.ts`
- `src/ui/components/category-filter.tsx`
- `src/utils/annotation-filters.ts`
- `tests/routes/import/PersonalNotePage.test.tsx`
- `tests/routes/books/book/annotation/AnnotationListPage.test.tsx`
- `tests/api.test.ts`
- `tests/models/annotations.test.ts`
- `tests/annotations.test.ts`
- `tests/metadataSerializer.test.ts`

## Incremental Execution Strategy

### Phase A: Domain + Serialization
1. Introduce `CategoryConfig` and default categories (`name`, `icon`) in settings/config.
2. Change annotation category type from `number` to `string` at domain edges.
3. Update metadata serializer/parser:
- write `category: <name>`
- parse strings
- treat numeric legacy values as uncategorized (`undefined`) for compatibility

### Phase B: UI + Filter Integration
1. Render import category buttons from settings instead of hardcoded array.
2. Add "add category" affordance with validated category name creation.
3. Update editor hook and filter components/types to use `string | null`.
4. Update `annotation-filters.ts` to compare category names (string equality).

### Phase C: Test and Regression Hardening
1. Update existing tests for string categories.
2. Add regression tests for:
- legacy numeric metadata deserialization fallback
- settings-driven category rendering
- category filter behavior with string categories
3. Re-run full suite and update snapshots only where behavior intentionally changed.

## Proposed Commit Topology
1. `test(story-016): add string-category contracts and legacy fallback coverage`  
2. `refactor(domain): switch category model and metadata serialization to string names`  
3. `feat(ui): drive category controls from settings and support category creation`  
4. `test(story-016): update snapshots and integration assertions for settings categories`  
5. `docs(story-016): update story checklist and execution notes`

## Parallelization Plan (Worktrees)
- Lane 1 (Domain): Phase A core typing + serializer changes.
- Lane 2 (UI): Phase B component/hook/settings plumbing.
- Lane 3 (Tests): Phase C assertions/snapshots based on merged behavior.

Note:
- Lane 2 depends partially on Lane 1 types; run Lane 1 first or rebase Lane 2 after Lane 1 merge.
- Lane 3 should run after Lane 1+2 to avoid churn.

## Verification Gates
1. `scripts/story-catalog.sh check`
2. `scripts/lint-docs.sh`
3. Targeted test pass:
- `npm test -- --runInBand tests/metadataSerializer.test.ts`
- `npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx`
- `npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx`
4. Full test suite:
- `npm test -- --runInBand`
5. Build:
- `OBSIDIAN_PLUGIN_DIR=. npm run build`

## Risks and Mitigations
- Risk: broad type migration breaks unrelated tests.
  - Mitigation: land domain/type changes first with targeted compatibility tests.
- Risk: snapshot churn masks regressions.
  - Mitigation: isolate snapshot commit and review it explicitly before merge.
- Risk: settings-driven categories diverge between import and card-creation routes.
  - Mitigation: assert both routes via integration tests and shared filter utility tests.


Test contract contents:
# Test Contract: STORY-016 Named Categories

**Story:** `docs/stories/STORY-016-customizable-annotation-categories.md`  
**Implementation Plan:** `docs/plans/STORY-016-named-categories-settings-config.md`  
**Mode:** Contract-first with green commits (no red commit required due pre-commit gates)

## Required Test Files
TEST_FILE: tests/metadataSerializer.test.ts
TEST_FILE: tests/models/annotations.test.ts
TEST_FILE: tests/routes/import/PersonalNotePage.test.tsx
TEST_FILE: tests/routes/books/book/annotation/AnnotationListPage.test.tsx
TEST_FILE: tests/api.test.ts

## Required Test Names
TEST_NAME: serializes string category names in metadata
TEST_NAME: ignores legacy numeric category metadata values
TEST_NAME: category buttons render from configured settings categories
TEST_NAME: selecting category saves category name string
TEST_NAME: MoonReader card creation category filter uses string categories

## Required Verification Commands
TEST_CMD: npm test -- --runInBand tests/metadataSerializer.test.ts
TEST_CMD: npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx
TEST_CMD: npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx
TEST_CMD: npm test -- --runInBand
TEST_CMD: OBSIDIAN_PLUGIN_DIR=. npm run build

## Notes
- This contract is enforced by `scripts/verify-test-contract.sh`.
- Delegated runs should pass this contract before handing control back for review.
mcp startup: no servers

thinking
**Starting autonomous implementation with strict TDD**
codex
Implementing STORY-016 in this worktree and branch only. I’ll first inspect the current category model and the plan/test-contract files, then add/adjust tests to fail before making code changes.
exec
/bin/bash -lc "sed -n '1,220p' docs/plans/STORY-016-named-categories-settings-config.md" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc 'git branch --show-current && pwd && rg --files | wc -l' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 2 in 50ms:
sed: can't read docs/plans/STORY-016-named-categories-settings-config.md: No such file or directory
 succeeded in 51ms:
feat/story-016-named-categories
/home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories
398
exec
/bin/bash -lc "sed -n '1,220p' docs/plans/STORY-016-test-contract.md" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 2 in 51ms:
sed: can't read docs/plans/STORY-016-test-contract.md: No such file or directory

thinking
**Listing docs and plans**
codex
I confirmed we’re on `feat/story-016-named-categories`. The scope files aren’t at `docs/plans/...` in this worktree, so I’m locating their actual paths and then I’ll continue against those exact documents.
exec
/bin/bash -lc "rg --files | rg 'STORY-016-(named-categories-settings-config|test-contract)\\.md|STORY-016'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
docs/stories/STORY-016-remove-filter-buttons-card-creation.md
docs/stories/STORY-016-customizable-annotation-categories.md
docs/plans/STORY-016-remove-filter-buttons.md

thinking
**Confirming scope content**
codex
The repository is missing `docs/plans/STORY-016-named-categories-settings-config.md` and `docs/plans/STORY-016-test-contract.md`; only older STORY-016 docs exist. I’ll proceed using the exact scope and test-contract content you provided in-message and note this path mismatch as a deviation in the final report.

thinking
**Inspecting touchpoint files and tests**
exec
/bin/bash -lc "sed -n '1,220p' src/config/annotation-categories.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/data/models/annotations.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/settings.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import { Icon } from "src/types/obsidian-icons";

export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
    "lightbulb",
    "quote",
    "whole-word",
    "sticky-note",
    "star",
    "asterisk"
];
 succeeded in 50ms:
import { deserializeMetadata } from "../utils/metadataSerializer";
import type { SourceCapabilities } from "./sourceCapabilities";

export interface annotation {
    type:           'annotation';
    id:             string;
    calloutType:    string;
    highlight:      string;
    note:           string;
    hasFlashcards?: boolean;
    flashcardCount?: number;
    // Metadata fields
    category?:      number;
    deleted?:       boolean;
    personalNote?:  string;
    origin?:        string;
    originalColor?: string;
    location?:      string;
    timestamp?:     string;
}
 succeeded in 50ms:
import { ObsidianNotice, Platform, PluginSettingTab, Setting, App, TFolder } from "src/infrastructure/obsidian-facade";
import React from "react";

import type SRPlugin from "src/main";
import { t } from "src/lang/helpers";

export interface SRSettings {
    // flashcards
    bookNotesPath: string;
    flashcardEasyText: string;
    flashcardGoodText: string;
    flashcardHardText: string;
    flashcardTags: string[];
    convertFoldersToDecks: boolean;
    cardCommentOnSameLine: boolean;
    burySiblingCards: boolean;
    showContextInCards: boolean;
    flashcardHeightPercentage: number;
    flashcardWidthPercentage: number;
    showFileNameInFileLink: boolean;
exec
/bin/bash -lc "sed -n '1,260p' src/data/utils/metadataSerializer.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
export interface AnnotationMetadata {
    original_color?: string;
    location?: string;
    timestamp?: string;
    category?: number;
    deleted?: boolean;
    personal_note?: string;
    origin?: string;
}

/**
 * Encapsulates the serialization and deserialization of annotation metadata
 * stored within Obsidian comments (%% ... %%).
 */
export function serializeMetadata(metadata: AnnotationMetadata): string {
    const parts: string[] = [];
    if (metadata.original_color) parts.push(`original_color: ${metadata.original_color}`);
    if (metadata.location) parts.push(`location: ${metadata.location}`);
    if (metadata.timestamp) parts.push(`timestamp: ${metadata.timestamp}`);
    if (metadata.category !== undefined && metadata.category !== null) parts.push(`category: ${metadata.category}`);
codex
I’ve confirmed the current model is numeric (`category?: number`) and metadata parser uses `parseInt`. Next I’m reading import/filter UI and existing tests so I can add failing contract tests before implementation.
exec
/bin/bash -lc "sed -n '1,260p' src/utils/annotation-filters.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/ui/routes/import/personal-note.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/ui/components/category-filter.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/ui/routes/import/useAnnotationEditor.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import { annotation } from "src/data/models/annotations";

export type AnnotationMainFilter = "unprocessed" | "processed" | "all";

export interface AnnotationFilter {
    mainFilter?: AnnotationMainFilter;
    categoryFilter?: number | null;
    colorFilter?: string | null;
}

export interface FilterableAnnotation {
    category?: number | null;
    deleted?: boolean;
    originalColor?: string;
}

export function matchesAnnotationFilter(ann: FilterableAnnotation, filter?: AnnotationFilter): boolean {
    if (ann.deleted) return false;
    if (!filter) return true;

 succeeded in 51ms:
import React, { useEffect, useRef } from "react";
import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
import { setIcon } from "src/infrastructure/obsidian-facade";
import { type Icon } from "src/types/obsidian-icons";
import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
import { getAnnotationById } from "src/api";
import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
import NavigationControl from "src/ui/components/NavigationControl";
import { pathGenerator } from "src/utils/path-generators";

export async function personalNoteLoader({ params }: any) {
    const { bookId, annotationId } = params;
    const annotation = await getAnnotationById(annotationId, bookId);
    return { annotation, bookId };
}

export function PersonalNotePage() {
    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
    const navigate = useNavigate();
 succeeded in 51ms:
import React, { useEffect, useRef } from "react";
import { setIcon } from "src/infrastructure/obsidian-facade";
import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
import { Icon } from "src/types/obsidian-icons";

interface CategoryFilterProps {
    selectedCategory: number | null;
    onCategorySelect: (category: number | null) => void;
}

export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed

    useEffect(() => {
        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
            if (iconRefs[i].current) {
                setIcon(iconRefs[i].current, iconName);
            }
        });
 succeeded in 50ms:
import { useState, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { updateAnnotationMetadata, softDeleteAnnotation } from "src/api";
import { integerToRGBA } from "src/utils/utils";

interface Annotation {
    id: string;
    highlight: string;
    note: string;
    personalNote?: string;
    category?: number | null;
    originalColor?: number;
}

export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
    const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
    const [selectedCategory, setSelectedCategory] = useState<number | null>(
        initialAnnotation.category !== undefined ? initialAnnotation.category : null
    );
    const navigate = useNavigate();

thinking
**Inspecting full interface definition**
exec
/bin/bash -lc "nl -ba src/ui/components/category-filter.tsx | sed -n '1,260p'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
     1	import React, { useEffect, useRef } from "react";
     2	import { setIcon } from "src/infrastructure/obsidian-facade";
     3	import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
     4	import { Icon } from "src/types/obsidian-icons";
     5	
     6	interface CategoryFilterProps {
     7	    selectedCategory: number | null;
     8	    onCategorySelect: (category: number | null) => void;
     9	}
    10	
    11	export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
    12	    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
    13	    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
    14	
    15	    useEffect(() => {
    16	        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
    17	            if (iconRefs[i].current) {
    18	                setIcon(iconRefs[i].current, iconName);
    19	            }
    20	        });

thinking
**Investigating undefined type issue**
codex
I found the import/editor/filter code still hardcoded to six numeric categories, and one filter component has stale typing. I’m now mapping all `category` usages to prepare a safe string migration and identify every test to update.
exec
/bin/bash -lc "rg -n \"category\\??:|categoryFilter|ANNOTATION_CATEGORY_ICONS|selectedCategory|handleCategoryClick\\(|updateAnnotationMetadata\\(|MoonReader\" src tests | sed -n '1,260p'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
src/application/import-api.ts:4:import { MoonReaderStrategy } from "src/data/models";
src/application/import-api.ts:50:    const strategy = new MoonReaderStrategy(mrexptPath);
src/application/import-api.ts:84:export async function importMoonReaderExport(mrexptPath: string, destinationFolder: string) {
src/application/import-api.ts:85:    const strategy = new MoonReaderStrategy(mrexptPath);
tests/api_orchestrator.test.ts:29:    test("importMoonReaderExport should move file and create annotations", async () => {
tests/api_orchestrator.test.ts:53:        const result = await api.importMoonReaderExport(
tests/api_orchestrator.test.ts:83:    test("importMoonReaderExport should archive existing annotations", async () => {
tests/api_orchestrator.test.ts:107:        await api.importMoonReaderExport("Attachments/Gatsby.mrexpt", "Books/Fiction");
src/application/annotation-api.ts:43:export async function updateAnnotationMetadata(
src/application/annotation-api.ts:54:    return await updateAnnotationMetadata(bookId, annotationId, { deleted: true });
tests/moonreader_snapshot.test.ts:1:import { parseMoonReaderExport } from "src/data/import/moonreader";
tests/moonreader_snapshot.test.ts:3:describe("MoonReader Parser - Snapshot Testing", () => {
tests/moonreader_snapshot.test.ts:8:/sdcard/Books/MoonReader/Memory A Very Short Introduction by Jonathan K. Foster.epub
tests/moonreader_snapshot.test.ts:23:        const result = parseMoonReaderExport(regularAnnotationRecord);
tests/moonreader_snapshot.test.ts:36:                "path": "/sdcard/Books/MoonReader/Memory A Very Short Introduction by Jonathan K. Foster.epub",
tests/moonreader_snapshot.test.ts:48:/sdcard/Books/MoonReader/Memory A Very Short Introduction by Jonathan K. Foster.epub
tests/moonreader_snapshot.test.ts:63:        const result = parseMoonReaderExport(bookmarkRecord);
tests/annotations.test.ts:11:            category: 1,
tests/annotations.test.ts:34:            category: null,
tests/routes/books/book/annotation/AnnotationListPage.test.tsx:37:            category: 2,

thinking
**Inspecting annotation display and types**
exec
/bin/bash -lc "sed -n '1,220p' src/application/annotation-api.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/ui/components/annotation-display-list.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/api.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,240p' tests/metadataSerializer.test.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import { CardType } from "src/types/CardType";
import type { annotation } from "src/data/models/annotations";
import { isHeading } from "src/data/models";
import { isAnnotationOrParagraph, isParagraph } from "src/data/models/sections/guards";
import { addBlockIdToParagraph } from "src/data/models/paragraphs";
import { getPluginContext } from "./plugin-context";

export function getAnnotationById(blockId: string, bookId: string) {
    const plugin = getPluginContext();
    const book = plugin.annotationsNoteIndex.getBook(bookId);
    return book.getAnnotation(blockId);
}

// TODO: create abstraction
export async function createFlashcardForAnnotation(
    question: string,
    answer: string,
    annotationId: string,
    bookId: string,
    cardType: CardType = CardType.MultiLineBasic
 succeeded in 50ms:
import React, { useEffect, useMemo, useState } from "react";
import { Link } from "react-router-dom";
import { annotation, SectionAnnotations } from "src/data/models/annotations";
import { getFilteredAnnotations } from "src/utils/annotation-filters";
import { integerToRGBA } from "src/utils/utils";
import { CategoryFilter } from "src/ui/components/category-filter";
import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
import {
    AnnotationListViewPolicy,
    AnnotationMainFilter,
} from "src/data/models/sourceCapabilities";

interface AnnotationListItemProps {
    annotation: annotation;
    baseLinkPath: string;
}

function AnnotationListItem(props: AnnotationListItemProps) {
    const highlightColor = useMemo(() => {
        if (props.annotation.originalColor) {
 succeeded in 50ms:
import type SRPlugin from "src/main";
import { setPluginContext } from "src/application/plugin-context";

export function setPlugin(p: SRPlugin) {
    setPluginContext(p);
}

export type { FlashCount, ReviewBook } from "src/application/review-api";
export {
    deleteFlashcard,
    getCurrentCard,
    getFlashcardById,
    getNextCard,
    getSourcesForReview,
    resetBookReviewState,
    updateFlashcardSchedulingMetadata,
} from "src/application/review-api";

export type { NotesWithoutBooks, frontEndBook } from "src/application/source-api";
export {
 succeeded in 50ms:
import { serializeMetadata } from "src/data/utils/metadataSerializer";

describe("serializeMetadata", () => {
    test("should serialize only deleted: true", () => {
        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
    });
});

thinking
**Reviewing test files for renaming**
exec
/bin/bash -lc "sed -n '1,280p' tests/routes/books/book/annotation/AnnotationListPage.test.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' tests/routes/import/PersonalNotePage.test.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' tests/models/annotations.test.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,340p' tests/api.test.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import React from "react";
import { fireEvent, render, screen, waitFor } from "@testing-library/react";
import { MemoryRouter } from "react-router-dom";
import { AnnotationListPage } from "src/ui/routes/books/book/annotation/AnnotationListPage";
import type { SectionAnnotations } from "src/data/models/annotations";
import type { SourceCapabilities } from "src/data/models/sourceCapabilities";

jest.mock("react-router-dom", () => ({
    ...jest.requireActual("react-router-dom"),
    useLoaderData: jest.fn(),
    useLocation: jest.fn(),
}));

const useLoaderDataMock = jest.requireMock("react-router-dom").useLoaderData as jest.Mock;
const useLocationMock = jest.requireMock("react-router-dom").useLocation as jest.Mock;

const NAVIGATION_FILTER_SESSION_KEY = "annotationNavigationFilter";

const chapterData: SectionAnnotations = {
    id: "section-1",
 succeeded in 50ms:
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { MemoryRouter } from "react-router-dom";
import { createDiskMockFromFixtures, resetFixtureTransformer } from "../../helpers";
import { PersonalNotePage } from "src/ui/routes/import/personal-note";
import * as obsidianFacade from "src/infrastructure/obsidian-facade";
import * as api from "src/api";
import { setupNanoidMock, resetNanoidMock } from "../../nanoid-mock";
import { createMockPlugin } from "../../__mocks__/plugin";
import { Index } from "src/data/models";
import { FlashcardIndex } from "src/data/models/flashcard";
import { AnnotationsNoteIndex } from "src/data/models/AnnotationsNote";
import { fileTags } from "src/infrastructure/disk";
import { setPlugin } from "src/api";

setupNanoidMock();

async function initializePlugin() {
    resetNanoidMock();
    resetFixtureTransformer();
 succeeded in 51ms:
import { isAnnotationProcessed } from "src/data/models/annotations";
import { createDiskMockFromFixtures } from "../helpers";
import { AnnotationsNote, AnnotationsNoteIndex } from "src/data/models/AnnotationsNote";
import { createMockPlugin } from "../__mocks__/plugin";
import { FlashcardIndex } from "src/data/models/flashcard";
import { fileTags } from "src/infrastructure/disk";
import { Index } from "src/data/models";

jest.mock("src/infrastructure/disk", () => {
    const mock = createDiskMockFromFixtures([
        "getFileContents_2025-12-07T19-37-22-044Z_radb6f.json",
        "getMetadataForFile_2025-12-07T19-37-22-036Z_kzjn5y.json",
        "getTFileForPath_Untitled.json",
    ]);
    return mock;
});

describe("isAnnotationProcessed", () => {
    test("should return true if annotation has a category", () => {
        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
 succeeded in 51ms:
import { createDiskMockFromFixtures } from "./helpers";
jest.mock("src/infrastructure/disk", () => {
    const mock = createDiskMockFromFixtures([
        "createFlashcardsFileForBook.json",
        "generateFlashcardsFileNameAndPath_2025-12-16T20-02-00_s93m1.json",
        "getAnnotationFilePath_2025-13-12T17-25-00_si3m1.json",
        "getMetadataForFile_2025-12-07T19-37-22-036Z_kzjn5y.json",
        "getFileContents_2025-12-07T19-37-21-944Z_bcx627.json",
        "getFileContents_2025-12-07T19-37-22-044Z_radb6f.json",
        "filePathsWithTag_2025-12-07T19-37-20-520Z_kx3kvy.json",
        "fileTags_2025-12-07T19-37-20-516Z_u0wrbc.json",
        "getTFileForPath_Untitled.json",
        "getTFileForPath_constitution.json",
        "getMetadataForFile_2025-12-07T19-37-20-679Z_gfsis2.json",
        "getMetadataForFile_constitution.json",
        "getFileContents_constitution.json",
        "generateFlashcardsFileNameAndPath_constitution.json",
        "createFlashcardsFileForBook_constitution.json",
        "moveFile_constitution.json",
        "ensureFolder_constitution.json",

thinking
**Focusing on test-related code area**
exec
/bin/bash -lc "sed -n '820,1120p' tests/api.test.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
                "category": undefined,
                "id": "tWxSv_No",
              },
              "prevCategory": undefined,
              "prevId": "tekXLAu8",
            }
        `);
    });

    test("observe section boundary behavior - no next after last annotation", () => {
        const bookId = "t0000010";
        const sectionId = "t0000012";
        const allAnnotations = getAnnotationsForSection(sectionId, bookId).annotations;
        const last = allAnnotations[allAnnotations.length - 1];

        const nextId = getNextAnnotationId(bookId, last.id, sectionId);

        expect({ lastAnnotationId: last.id, nextId }).toMatchInlineSnapshot(`
            {
              "lastAnnotationId": "tWxSv_No",

thinking
**Reviewing test and serializer relevance**
exec
/bin/bash -lc "sed -n '1,220p' tests/annotations.test.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
import { parseAnnotations, isAnnotationProcessed } from "src/data/models/annotations";

describe("isAnnotationProcessed", () => {
    test("should return true if annotation has a category", () => {
        const annotation = {
            type: "annotation",
            id: "1",
            calloutType: "note",
            highlight: "hi",
            note: "",
            category: 1,
        };
        expect(isAnnotationProcessed(annotation)).toBe(true);
    });

    test("should return false if annotation has no category", () => {
        const annotation = {
            type: "annotation",
            id: "2",
            calloutType: "note",

thinking
**Inspecting plugin context usage**
exec
/bin/bash -lc "sed -n '1,220p' src/application/plugin-context.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import type SRPlugin from "src/main";

let plugin: SRPlugin;

export function setPluginContext(p: SRPlugin) {
    plugin = p;
}

export function getPluginContext(): SRPlugin {
    return plugin;
}

thinking
**Inspecting plugin structure**
exec
/bin/bash -lc "sed -n '1,260p' src/main.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import { Plugin } from "obsidian";
import { FlashcardModal } from "src/ui/modals/flashcard-modal";
import { appIcon } from "src/icons/appicon";
import { t } from "src/lang/helpers";
import { DEFAULT_SETTINGS, SRSettings, SRSettingTab } from "src/settings";
import { FlashcardIndex } from "src/data/models/flashcard";
import { AnnotationsNoteIndex } from "src/data/models/annotations-note/AnnotationsNoteIndex";
import { fileTags } from "src/infrastructure/disk";
import { setPlugin } from "src/api";
import { ObsidianNotice, setApp } from "src/infrastructure/obsidian-facade";
import { Index } from "src/data/models";
import { AnnotationsNoteDependencies } from "src/data/utils/dependencies";

export interface PluginData {
    settings: SRSettings;
    buryDate: string;
    // hashes of card texts
    // should work as long as user doesn't modify card's text
    // which covers most of the cases
    buryList: string[];

thinking
**Adding default category settings**
exec
/bin/bash -lc "sed -n '1,260p' src/data/models/sourceCapabilities.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import type { SourceType } from "src/data/source-discovery";

export type AnnotationMainFilter = "unprocessed" | "processed" | "all";
export type AnnotationListFlow = "import" | "card-creation";
export type CardCreationMode = "processed-category" | "all-no-processing";

export interface SourceCapabilities {
    sourceType: SourceType;
    cardCreationMode: CardCreationMode;
    showCategoryFilter: boolean;
    showColorFilter: boolean;
    supportsProcessingFlow: boolean;
    requiresMutationConfirmation: boolean;
}

export interface AnnotationListViewPolicy {
    defaultMainFilter: AnnotationMainFilter;
    enforcedMainFilter: AnnotationMainFilter | null;
    showMainFilterButtons: boolean;
    showCategoryFilter: boolean;

thinking
**Considering category filter parameter**
codex
Next I’m checking navigation/filter APIs and serializer callsites for numeric assumptions, then I’ll write the required failing tests with the exact names from the contract.
exec
/bin/bash -lc "sed -n '1,260p' src/application/navigation-api.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/data/models/annotations-note/AnnotationsNote.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/data/utils/annotationGenerator.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,260p' src/ui/routes/books/book/annotation/AnnotationListPage.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import type { annotation } from "src/data/models/annotations";
import { paragraph } from "src/data/models/paragraphs";
import { isAnnotationOrParagraph, isHeading } from "src/data/models";
import { AnnotationFilter, matchesAnnotationFilter } from "src/utils/annotation-filters";
import { getPluginContext } from "./plugin-context";

export type NavigationFilter = AnnotationFilter;

export function getPreviousAnnotationId(
    bookId: string,
    blockId: string,
    sectionId?: string,
    filter?: NavigationFilter
) {
    const plugin = getPluginContext();
    const book = plugin.annotationsNoteIndex.getBook(bookId);
    const index = book.bookSections.findIndex(t => t.id === blockId);
    if (index === -1) return null;

    for (let i = index - 1; i >= 0; i--) {
 succeeded in 50ms:
import { nanoid } from "nanoid";
import {
    createFlashcardsFileForBook,
    generateFlashcardsFileNameAndPath,
} from "src/infrastructure/disk";
import type { annotation } from "src/data/models/annotations";
import type { paragraph } from "src/data/models/paragraphs";
import { Flashcard, FlashcardNote } from "src/data/models/flashcard";
import type { ReviewResponse } from "src/types/CardType";
import { CardType } from "src/types/CardType";
import type { AnnotationsNoteDependencies } from "src/data/utils/dependencies";
import type { FlashcardSourceStrategy } from "../FlashcardSourceStrategy";
import { getSourceCapabilities as buildSourceCapabilities, type SourceCapabilities } from "../sourceCapabilities";
import type { BookMetadataSections, Heading } from "../sections/types";
import { isAnnotationOrParagraph, isParagraph } from "../sections/guards";
import { updateAnnotationOnDisk } from "./annotation-persistence";
import { computeAnnotationCoverage } from "./annotation-coverage";
import {
    createFlashcardForAnnotation,
    deleteFlashcardById,
 succeeded in 51ms:
import { MoonReaderAnnotation } from "src/data/import/moonreader";
import { serializeMetadata } from "./metadataSerializer";
import { annotation } from "../models/annotations";

/**
 * Renders an internal annotation model to its Markdown representation.
 * This is the canonical way annotations are stored on disk.
 */
export function renderAnnotation(ann: annotation): string {
    const metadataText = serializeMetadata({
        original_color: ann.originalColor,
        location: ann.location,
        timestamp: ann.timestamp,
        category: ann.category,
        deleted: ann.deleted,
        personal_note: ann.personalNote,
        origin: ann.origin,
    });
    const noteContent = ann.note ? `\n> ${ann.note}` : "";

 succeeded in 51ms:
import React from "react";
import { useLoaderData, useLocation } from "react-router-dom";
import { AnnotationDisplayList } from "src/ui/components/annotation-display-list";
import { SectionAnnotations } from "src/data/models/annotations";
import { USE_JSON_MOCK } from "src/ui/routes/books/review";
import { getAnnotationsForSection, getSourceCapabilities } from "src/api";
import {
    AnnotationMainFilter,
    getAnnotationListViewPolicy,
} from "src/data/models/sourceCapabilities";

export interface AnnotationsLoaderParams {
    bookId: string;
    sectionId: string;
}

export function annotationsLoader({params}: {params: AnnotationsLoaderParams}) {
    if (!USE_JSON_MOCK) {
        const sectionData = getAnnotationsForSection(params.sectionId, params.bookId);
        if (!sectionData) return sectionData;

thinking
**Planning fallback for settings categories**
exec
/bin/bash -lc "sed -n '1,260p' tests/__mocks__/plugin.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
// tests/__mocks__/plugin.ts

import { AnnotationsNoteDependencies } from "src/data/utils/dependencies";

// This mock is designed to be very lightweight and synchronous for Jest's module mocking.

/**
 * Creates a mock instance of the SRPlugin for testing.
 *
 * @param overrides - An object to override specific properties of the mock plugin.
 *                    This allows you to tailor the mock's behavior for each test.
 *                    For example, you can provide a mock implementation for `annotationsNoteIndex.getBook`.
 */
export function createMockPlugin(overrides?: any): AnnotationsNoteDependencies {
    const defaultMock = {
        // Mock the properties that your API functions actually use
        annotationsNoteIndex: {
            getBook: jest.fn().mockReturnValue(null), // Default to returning null
            getSourcesForReview: jest.fn().mockReturnValue([]),
            getSourcesWithoutFlashcards: jest.fn().mockReturnValue([]),

thinking
**Planning type updates for annotations**
exec
/bin/bash -lc "sed -n '1,260p' src/data/models/annotations-note/annotation-persistence.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,220p' src/data/models/paragraphs.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc "sed -n '1,240p' src/data/models/annotations-note/annotation-transform.ts" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
import type { annotation } from "src/data/models/annotations";
import { renderAnnotation } from "src/data/utils/annotationGenerator";
import { updateCardOnDisk } from "src/infrastructure/disk";
import type { BookMetadataSections } from "../sections/types";

export async function updateAnnotationOnDisk(
    sourcePath: string,
    bookSections: BookMetadataSections,
    annotationId: string,
    updates: Partial<annotation>
) {
    const annotationIndex = bookSections.findIndex(t => t.id === annotationId);
    if (annotationIndex === -1) throw new Error(`updateAnnotation: annotation not found for id ${annotationId}`);
    const originalAnnotation = bookSections[annotationIndex];

    const originalMarkdown = renderAnnotation(originalAnnotation);

    const updatedAnnotation = { ...originalAnnotation, ...updates };
    const updatedMarkdown = renderAnnotation(updatedAnnotation);

 succeeded in 50ms:
import type { annotation } from "src/data/models/annotations";
import type { paragraph } from "src/data/models/paragraphs";
import { isAnnotation } from "src/data/models/sections/guards";

export function toAnnotationLike(p: paragraph | annotation): annotation {
    if (isAnnotation(p)) {
        return p;
    }
    return {
        type: "annotation",
        id: p.id,
        calloutType: "",
        note: "",
        highlight: p.text,
        hasFlashcards: p.hasFlashcards,
    };
}
 succeeded in 50ms:
import { nanoid } from "nanoid";
import { getFileContents, getMetadataForFile } from "../../infrastructure/disk";
import { Flashcard } from "./flashcard";
import { Heading } from "./AnnotationsNote";

export interface paragraph {
    type: 'paragraph',
    id: string,
    text: string,
    wasIdPresent: boolean,
    hasFlashcards: boolean,
    fingerprint?: string,
    drifted?: boolean
}

// todo: edge case where there are no headings
export async function extractParagraphs(filePath: string, flashcards: Flashcard[]): Promise<paragraph[]> {
    const metadata = getMetadataForFile(filePath);
    // get blocks with blockid if present
    const paragraphsOrHeadings = metadata?.sections?.filter(t => t.type == "paragraph" || t.type == "heading");

thinking
**Inspecting category handling in notes**
codex
I’ve mapped all category-related callsites and identified the key ones to migrate (`metadataSerializer`, `annotation` model, import editor hook/page, category filter, and navigation/list filtering). I’m now editing the contract tests first so they fail against current numeric behavior, then I’ll implement to green.

thinking
**Adding and naming targeted tests**
exec
/bin/bash -lc "sed -n '1,280p' scripts/verify-test-contract.sh" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 2 in 51ms:
sed: can't read scripts/verify-test-contract.sh: No such file or directory

thinking
**Focusing on metadataSerializer test edits**
codex
I’m starting the red phase now by updating `tests/metadataSerializer.test.ts` with explicit string-category serialization/deserialization expectations and a legacy numeric fallback assertion that should fail on current code.
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/metadataSerializer.test.ts
@@ -1,6 +1,14 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M tests/metadataSerializer.test.ts
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });

file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });


thinking
**Updating tests with required names**
exec
/bin/bash -lc 'rg -n "category|sr-category-button|setIcon|Save|category buttons|renders" tests/routes/import/PersonalNotePage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
78:// Mock Obsidian setIcon
81:    setIcon: jest.fn(),
88:const setIconMock = jest.spyOn(obsidianFacade, "setIcon");
108:        setIconMock.mockClear();
216:    it("should render correctly with a personal note, category, and highlight color and match snapshot", () => {
222:            category: 2,
239:        expect(setIconMock).toHaveBeenCalledWith(expect.any(HTMLDivElement), "lightbulb"); // Check that icons are set
312:                  class="sr-category-buttons"
316:                    class="sr-category-button is-clickable "
322:                    class="sr-category-button is-clickable "
328:                    class="sr-category-button is-clickable is-active"
334:                    class="sr-category-button is-clickable "
340:                    class="sr-category-button is-clickable "
346:                    class="sr-category-button is-clickable "
358:                    Save
369:    it("should render correctly with no personal note, category, or highlight color and match snapshot", () => {
375:            category: undefined,
390:        expect(setIconMock).toHaveBeenCalledTimes(9); // 6 category icons + 1 delete icon + 2 nav icons
457:                  class="sr-category-buttons"
461:                    class="sr-category-button is-clickable "
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });

exec
/bin/bash -lc "sed -n '500,660p' tests/routes/import/PersonalNotePage.test.tsx" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
                  <button
                    class="mod-cta"
                  >
                    Save
                  </button>
                  <button>
                    Back
                  </button>
                </div>
              </div>
            </div>
        `);
    });

    it("should handle category click and update state", async () => {
        const mockAnnotation = {
            id: mockAnnotationId,
            highlight: "Highlight",
            note: "Note",
            personalNote: "",
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });


thinking
**Adding tests for category buttons**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/routes/import/PersonalNotePage.test.tsx
@@ -95,2 +95,3 @@
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
@@ -98,4 +99,4 @@
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
@@ -513,2 +514,27 @@
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
@@ -543,3 +569,7 @@
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
@@ -549,3 +579,3 @@
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
@@ -573,3 +603,3 @@
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
@@ -607,2 +637,2 @@
     });
-});
\ No newline at end of file
+});
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M tests/routes/import/PersonalNotePage.test.tsx
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Adjusting category filters to strings**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -36,3 +36,3 @@
             note: "",
-            category: 2,
+            category: "quote",
         },
@@ -124,2 +124,24 @@
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
@@ -181,3 +203,3 @@
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M tests/routes/books/book/annotation/AnnotationListPage.test.tsx
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning annotation test updates**
codex
I’ve added failing contract tests for metadata, import page, and annotation-list behavior with string category expectations. I’m now updating `tests/models/annotations.test.ts` and `tests/api.test.ts` to align with string categories and complete the required file coverage before running red tests.

thinking
**Patching models and API tests**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/models/annotations.test.ts
@@ -19,3 +19,3 @@
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M tests/models/annotations.test.ts
file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning targeted test patch**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/api.test.ts
@@ -899,3 +899,3 @@
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
@@ -917,3 +917,3 @@
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
@@ -934,3 +934,3 @@
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
@@ -966,3 +966,3 @@
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
@@ -986,3 +986,3 @@
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
@@ -1009,3 +1009,3 @@
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
@@ -1015,3 +1015,3 @@
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
@@ -1039,3 +1039,3 @@
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M tests/api.test.ts
file update:
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running targeted failing tests**
exec
/bin/bash -lc 'npm test -- --runInBand tests/metadataSerializer.test.ts' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 1 in 1.71s:

> card-coverage@0.2.0 test
> jest --runInBand tests/metadataSerializer.test.ts

FAIL tests/metadataSerializer.test.ts
  ● metadataSerializer › ignores legacy numeric category metadata values

    expect(received).toEqual(expected) // deep equality

    - Expected  - 1
    + Received  + 3

    - Object {}
    + Object {
    +   "category": 2,
    + }

       7 |
       8 |     test("ignores legacy numeric category metadata values", () => {
    >  9 |         expect(deserializeMetadata("category: 2")).toEqual({});
file update:
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Confirming expected test failure**
codex
Red phase confirmed: metadata test fails on numeric legacy parsing. I’ll run the two UI contract tests now to capture the additional expected failures before implementing.
exec
/bin/bash -lc 'npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 1 in 4.22s:
FAIL tests/routes/import/PersonalNotePage.test.tsx
  ● PersonalNotePage Component › category buttons render from configured settings categories

    expect(received).toHaveLength(expected)

    Expected length: 3
    Received length: 6
    Received object: [<div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>, <div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>, <div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>, <div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>, <div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>, <div class="sr-category-button is-clickable " style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"><div /></div>]

      535 |         );
      536 |
    > 537 |         expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
          |                                                                   ^
      538 |     });
      539 |
      540 |     it("should handle category click and update state", async () => {

      at tests/routes/import/PersonalNotePage.test.tsx:537:67
      at ../../node_modules/tslib/tslib.js:117:75
      at __awaiter (../../node_modules/tslib/tslib.js:113:16)
file update:
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Noticing test failure**
exec
/bin/bash -lc 'npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 1 in 4.22s:
FAIL tests/routes/books/book/annotation/AnnotationListPage.test.tsx
  ● AnnotationListPage route context behavior › MoonReader card creation category filter uses string categories

    expect(received).toEqual(expected) // deep equality

    - Expected  - 1
    + Received  + 1

      Object {
    -   "categoryFilter": "insight",
    +   "categoryFilter": 0,
        "colorFilter": null,
        "mainFilter": "processed",
      }

    Ignored nodes: comments, script, style
    [36m<html>[39m
      [36m<head />[39m
      [36m<body>[39m
        [36m<div>[39m
file update:
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning comprehensive category refactor**
codex
Moving to implementation: I’m refactoring the category domain to `string` with settings-backed `CategoryConfig`, then wiring import/filter UI to those settings and adding legacy numeric-metadata fallback in deserialization. After that I’ll run the contract commands and fix any regressions.

thinking
**Applying config patch**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/config/annotation-categories.ts
@@ -2,9 +2,27 @@
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M src/config/annotation-categories.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Adding property import to settings**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/settings.ts
@@ -5,2 +5,3 @@
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
@@ -43,2 +44,3 @@
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
@@ -81,3 +83,4 @@
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: DEFAULT_ANNOTATION_CATEGORIES,
 };
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/settings.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..78369a38db1c9d085e69d123e1a8323cb63e307e
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: DEFAULT_ANNOTATION_CATEGORIES,
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..78369a38db1c9d085e69d123e1a8323cb63e307e
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: DEFAULT_ANNOTATION_CATEGORIES,
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Avoiding shared array mutation**
🌐 Searching the web...
🌐 Searched the web

thinking
**Planning quick patch**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/settings.ts
@@ -84,3 +84,3 @@
     showDebugMessages: false,
-    annotationCategories: DEFAULT_ANNOTATION_CATEGORIES,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/settings.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Refining metadata serialization types**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/data/utils/metadataSerializer.ts
@@ -4,3 +4,3 @@
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
@@ -49,3 +49,5 @@
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/data/utils/metadataSerializer.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Implementing annotation model patch**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/data/models/annotations.ts
@@ -12,3 +12,3 @@
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M src/data/models/annotations.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Applying annotation editor patch**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/routes/import/useAnnotationEditor.ts
@@ -10,3 +10,3 @@
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
@@ -16,3 +16,3 @@
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
@@ -28,4 +28,4 @@
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M src/ui/routes/import/useAnnotationEditor.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning large patch rewrite**
codex
I’m editing `PersonalNotePage` now: dynamic categories from settings, string category selection, and an inline “add category” control with simple validation and settings persistence.
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/routes/import/personal-note.tsx
@@ -1,11 +1,16 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    DEFAULT_ANNOTATION_CATEGORIES,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
@@ -17,4 +22,4 @@
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
@@ -34,11 +39,11 @@
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
@@ -56,13 +61,38 @@
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
@@ -121,20 +151,33 @@
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M src/ui/routes/import/personal-note.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..8215a43114751a9e936516bd8073f29eeb9e08e0
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,18 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    DEFAULT_ANNOTATION_CATEGORIES,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +20,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +37,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +59,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +149,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..8215a43114751a9e936516bd8073f29eeb9e08e0
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,18 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    DEFAULT_ANNOTATION_CATEGORIES,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +20,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +37,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +59,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +149,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Cleaning unused import and handling undefined plugin**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/routes/import/personal-note.tsx
@@ -11,3 +11,2 @@
     type CategoryConfig,
-    DEFAULT_ANNOTATION_CATEGORIES,
     resolveAnnotationCategories,
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/ui/routes/import/personal-note.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning complete category-filter rewrite**
file update
D /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/components/category-filter.tsx
import React, { useEffect, useRef } from "react";
import { setIcon } from "src/infrastructure/obsidian-facade";
import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
import { Icon } from "src/types/obsidian-icons";

interface CategoryFilterProps {
    selectedCategory: number | null;
    onCategorySelect: (category: number | null) => void;
}

export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed

    useEffect(() => {
        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
            if (iconRefs[i].current) {
                setIcon(iconRefs[i].current, iconName);
            }
        });
        // if (clearFilterRef.current) { // No longer needed
        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
        // }
    }, []);

    const handleCategoryClick = (categoryIndex: number) => {
        if (selectedCategory === categoryIndex) {
            onCategorySelect(null);
        } else {
            onCategorySelect(categoryIndex);
        }
    };

    return (
        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
                <div
                    key={i}
                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
                    onClick={() => handleCategoryClick(i)}
                    style={{
                        padding: "8px",
                        border: "1px solid",
                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
                        borderRadius: "4px",
                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
                    }}
                >
                    <div ref={iconRefs[i]} />
                </div>
            ))}
            {/* The clear category button is removed as per the new toggle behavior */}
        </div>
    );
}
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
D src/ui/components/category-filter.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
deleted file mode 100644
index b25ef879694e2b58c74361794cf83cd3a1e015ef..0000000000000000000000000000000000000000
--- a/src/ui/components/category-filter.tsx
+++ /dev/null
@@ -1,55 +0,0 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
deleted file mode 100644
index b25ef879694e2b58c74361794cf83cd3a1e015ef..0000000000000000000000000000000000000000
--- a/src/ui/components/category-filter.tsx
+++ /dev/null
@@ -1,55 +0,0 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update
A /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/components/category-filter.tsx
import React, { useEffect, useRef } from "react";
import { setIcon } from "src/infrastructure/obsidian-facade";
import type { CategoryConfig } from "src/config/annotation-categories";

interface CategoryFilterProps {
    categories: CategoryConfig[];
    selectedCategory: string | null;
    onCategorySelect: (category: string | null) => void;
}

export function CategoryFilter({
    categories,
    selectedCategory,
    onCategorySelect,
}: CategoryFilterProps) {
    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);

    useEffect(() => {
        categories.forEach((category, i) => {
            const iconRef = iconRefs.current[i];
            if (iconRef) {
                setIcon(iconRef, category.icon);
            }
        });
    }, [categories]);

    const handleCategoryClick = (categoryName: string) => {
        if (selectedCategory === categoryName) {
            onCategorySelect(null);
        } else {
            onCategorySelect(categoryName);
        }
    };

    return (
        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
            {categories.map((category, i) => (
                <div
                    key={category.name}
                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
                    onClick={() => handleCategoryClick(category.name)}
                    style={{
                        padding: "8px",
                        border: "1px solid",
                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
                        borderRadius: "4px",
                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
                    }}
                >
                    <div ref={(element) => { iconRefs.current[i] = element; }} />
                </div>
            ))}
        </div>
    );
}
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
A src/ui/components/category-filter.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Updating category annotation display**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/ui/components/annotation-display-list.tsx
@@ -6,3 +6,3 @@
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
@@ -11,2 +11,3 @@
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
@@ -86,3 +87,5 @@
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
@@ -161,2 +164,3 @@
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/ui/components/annotation-display-list.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Updating annotation-filter types**
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/src/utils/annotation-filters.ts
@@ -6,3 +6,3 @@
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
@@ -11,3 +11,3 @@
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
@@ -45,3 +45,3 @@
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M src/utils/annotation-filters.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning category type refactor**
exec
/bin/bash -lc "rg -n \"category\\?:\\s*number|selectedCategory:\\s*number|categoryFilter:\\s*number|onCategorySelect: \\(category: number|handleCategoryClick\\(index: number|category === i|categoryFilter: 0|category: 0|category: 1|category: 2|category: 3\" src | sed -n '1,260p'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Searching numeric assumptions**
codex
Core refactor is in place. I’m running a quick compile-oriented test sweep of the touched areas now, then I’ll fix remaining type/runtime mismatches and proceed through the required verification commands.
exec
/bin/bash -lc "rg -n \"categoryFilter|selectedCategory|annotationCategories|resolveAnnotationCategories|category:\" src/ui src/data src/utils | sed -n '1,320p'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
src/utils/annotation-filters.ts:7:    categoryFilter?: string | null;
src/utils/annotation-filters.ts:26:        if (filter.categoryFilter !== undefined && filter.categoryFilter !== null) {
src/utils/annotation-filters.ts:27:            return category === filter.categoryFilter;
src/utils/annotation-filters.ts:46:    categoryFilter: string | null,
src/utils/annotation-filters.ts:52:            categoryFilter,
src/data/models/annotations.ts:54:            category: metadata.category,
src/ui/components/annotation-display-list.tsx:7:import { resolveAnnotationCategories } from "src/config/annotation-categories";
src/ui/components/annotation-display-list.tsx:90:    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
src/ui/components/annotation-display-list.tsx:126:                categoryFilter: activeCategoryFilter,
src/ui/components/annotation-display-list.tsx:166:                            selectedCategory={activeCategoryFilter}
src/ui/components/category-filter.tsx:7:    selectedCategory: string | null;
src/ui/components/category-filter.tsx:8:    onCategorySelect: (category: string | null) => void;
src/ui/components/category-filter.tsx:13:    selectedCategory,
src/ui/components/category-filter.tsx:28:        if (selectedCategory === categoryName) {
src/ui/components/category-filter.tsx:40:                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
src/ui/components/category-filter.tsx:45:                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
src/ui/components/category-filter.tsx:47:                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
src/data/utils/annotationGenerator.ts:14:        category: ann.category,
src/data/utils/metadataSerializer.ts:20:    if (metadata.category !== undefined && metadata.category !== null) parts.push(`category: ${metadata.category}`);
src/ui/routes/import/personal-note.tsx:12:    resolveAnnotationCategories,
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running targeted tests**
exec
/bin/bash -lc 'npm test -- --runInBand tests/metadataSerializer.test.ts' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 1.68s:
PASS tests/metadataSerializer.test.ts

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.059 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

exec
/bin/bash -lc 'npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 1 in 2.55s:
FAIL tests/routes/import/PersonalNotePage.test.tsx
  ● PersonalNotePage Component › should render correctly with a personal note, category, and highlight color and match snapshot

    expect(received).toMatchInlineSnapshot(snapshot)

    Snapshot name: `PersonalNotePage Component should render correctly with a personal note, category, and highlight color and match snapshot 1`

    - Snapshot  -  2
    + Received  + 14

    @@ -83,12 +83,12 @@
              style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"
            >
              <div />
            </div>
            <div
    -         class="sr-category-button is-clickable is-active"
    -         style="padding: 10px; border: 2px solid; border-radius: 4px;"
    +         class="sr-category-button is-clickable "
    +         style="padding: 10px; border: 2px solid; border-radius: 4px; background-color: transparent;"
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..246b2a338a1e60ff02c5150f41736b48371a0f49
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Updating mock category values**
codex
The import-page test failures are now snapshot-only plus one outdated numeric fixture value. I’m fixing that fixture to a string category and then updating only the intentional snapshots for this file.
file update
M /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories/tests/routes/import/PersonalNotePage.test.tsx
@@ -222,3 +222,3 @@
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M tests/routes/import/PersonalNotePage.test.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..36a9ff3ccbd6c6b2d4358c62ade513dc048f0ddc
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +220,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..36a9ff3ccbd6c6b2d4358c62ade513dc048f0ddc
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -93,11 +93,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +220,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -511,6 +512,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +567,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +601,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +635,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Updating test snapshots**
exec
/bin/bash -lc 'npm test -- --runInBand -u tests/routes/import/PersonalNotePage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 3.16s:
(node:1230) Warning: `--localstorage-file` was provided without a valid path
(Use `node --trace-warnings ...` to show where the warning was created)
PASS tests/routes/import/PersonalNotePage.test.tsx
 › 2 snapshots updated.

Snapshot Summary
 › 2 snapshots updated from 1 test suite.

Test Suites: 1 passed, 1 total
Tests:       10 passed, 10 total
Snapshots:   2 updated, 2 total
Time:        2.481 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running annotation list tests**
exec
/bin/bash -lc 'npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 2.32s:

> card-coverage@0.2.0 test
> jest --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx

PASS tests/routes/books/book/annotation/AnnotationListPage.test.tsx

Test Suites: 1 passed, 1 total
Tests:       6 passed, 6 total
Snapshots:   0 total
Time:        1.528 s, estimated 4 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running targeted model tests**
exec
/bin/bash -lc 'npm test -- --runInBand tests/models/annotations.test.ts' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 1.61s:
PASS tests/models/annotations.test.ts

Test Suites: 1 passed, 1 total
Tests:       4 passed, 4 total
Snapshots:   0 total
Time:        1.062 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running API test**
exec
/bin/bash -lc 'npm test -- --runInBand tests/api.test.ts' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 1.91s:
PASS tests/api.test.ts

Test Suites: 1 passed, 1 total
Tests:       4 skipped, 40 passed, 44 total
Snapshots:   19 passed, 19 total
Time:        1.336 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Including required verification commands**
codex
Targeted contract tests are green after implementation. I’m now executing the full verification gate sequence from the scope (including docs scripts, full test suite, and build) and will report any gate deviations if scripts are missing in this worktree.
exec
/bin/bash -lc 'scripts/story-catalog.sh check' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 127 in 51ms:
/bin/bash: line 1: scripts/story-catalog.sh: No such file or directory
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

exec
/bin/bash -lc scripts/lint-docs.sh in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories exited 127 in 50ms:
/bin/bash: line 1: scripts/lint-docs.sh: No such file or directory
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Planning targeted command reruns**
exec
/bin/bash -lc 'npm test -- --runInBand tests/metadataSerializer.test.ts' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc 'npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categoriesexec
/bin/bash -lc 'npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 1.91s:

> card-coverage@0.2.0 test
> jest --runInBand tests/metadataSerializer.test.ts

PASS tests/metadataSerializer.test.ts

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.035 s
 succeeded in 2.36s:

> card-coverage@0.2.0 test
> jest --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx

PASS tests/routes/books/book/annotation/AnnotationListPage.test.tsx

Test Suites: 1 passed, 1 total
Tests:       6 passed, 6 total
Snapshots:   0 total
Time:        1.484 s, estimated 2 s
 succeeded in 2.94s:

> card-coverage@0.2.0 test
> jest --runInBand tests/routes/import/PersonalNotePage.test.tsx

PASS tests/routes/import/PersonalNotePage.test.tsx

Test Suites: 1 passed, 1 total
Tests:       10 passed, 10 total
Snapshots:   2 passed, 2 total
Time:        1.977 s, estimated 3 s
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Running full suite and build**
codex
I’m running the remaining mandatory gates now: full test suite and build. After that, I’ll commit if everything stays green.
exec
/bin/bash -lc 'npm test -- --runInBand' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 6.48s:
PASS tests/disk.test.ts
PASS tests/routes/import/ImportDashboard.test.tsx
PASS tests/book.test.ts
PASS tests/annotations.test.ts
PASS tests/parser.test.ts
PASS tests/deck-landing-page.test.tsx
PASS tests/paragraphs.test.ts
PASS tests/api.clippings.test.ts
PASS tests/annotationGenerator.test.ts
PASS tests/components/PreviewExistingFlashcards.test.tsx
PASS tests/scheduling.test.ts
PASS tests/lang/helpers.test.ts
PASS tests/routes_books_api.test.ts
PASS tests/annotation_with_outlet.test.tsx
PASS tests/api_orchestrator.test.ts
PASS tests/components/ChapterList.test.tsx
PASS tests/personal-note-page.test.tsx
PASS tests/moonreader_parser.test.ts
PASS tests/deckbuilder.test.ts
PASS tests/data/utils/fingerprint.test.ts
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Building project**
exec
/bin/bash -lc 'OBSIDIAN_PLUGIN_DIR=. npm run build' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 451ms:

  main.js  2.0mb ⚠️

⚡ Done in 259ms
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Checking git status and diffs**
exec
/bin/bash -lc 'git status --short' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 50ms:
 M src/config/annotation-categories.ts
 M src/data/models/annotations.ts
 M src/data/utils/metadataSerializer.ts
 M src/settings.ts
 M src/ui/components/annotation-display-list.tsx
 M src/ui/components/category-filter.tsx
 M src/ui/routes/import/personal-note.tsx
 M src/ui/routes/import/useAnnotationEditor.ts
 M src/utils/annotation-filters.ts
 M tests/api.test.ts
 M tests/metadataSerializer.test.ts
 M tests/models/annotations.test.ts
 M tests/routes/books/book/annotation/AnnotationListPage.test.tsx
 M tests/routes/import/PersonalNotePage.test.tsx
?? main.js
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Checking main.js tracking status**
exec
/bin/bash -lc 'git ls-files main.js && ls -l main.js' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
-rw-r--r-- 1 abhishek abhishek 2045411 Feb 20 19:38 main.js
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Preparing commit excluding main.js**
codex
All required test/build gates are green. I’m preparing a single scoped commit with the STORY-016 changes and excluding generated `main.js` from version control.

thinking
**Preparing explicit git commit**
exec
/bin/bash -lc 'git add src/config/annotation-categories.ts src/data/models/annotations.ts src/data/utils/metadataSerializer.ts src/settings.ts src/ui/components/annotation-display-list.tsx src/ui/components/category-filter.tsx src/ui/routes/import/personal-note.tsx src/ui/routes/import/useAnnotationEditor.ts src/utils/annotation-filters.ts tests/api.test.ts tests/metadataSerializer.test.ts tests/models/annotations.test.ts tests/routes/books/book/annotation/AnnotationListPage.test.tsx tests/routes/import/PersonalNotePage.test.tsx && git commit -m "feat(story-016): migrate annotation categories to settings-driven names"' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
[feat/story-016-named-categories 2d4e99f] feat(story-016): migrate annotation categories to settings-driven names
 14 files changed, 303 insertions(+), 147 deletions(-)
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Verifying commit file changes**
exec
/bin/bash -lc 'git status --short' in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
?? main.js
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Summarizing final changes and tests**
exec
/bin/bash -lc "git show --name-only --pretty=format: --stat 2d4e99f | sed '/"'^$/d'"'" in /home/abhishek/github/obsidian-spaced-repetition/.worktrees/feat-story-016-named-categories succeeded in 51ms:
src/config/annotation-categories.ts
src/data/models/annotations.ts
src/data/utils/metadataSerializer.ts
src/settings.ts
src/ui/components/annotation-display-list.tsx
src/ui/components/category-filter.tsx
src/ui/routes/import/personal-note.tsx
src/ui/routes/import/useAnnotationEditor.ts
src/utils/annotation-filters.ts
tests/api.test.ts
tests/metadataSerializer.test.ts
tests/models/annotations.test.ts
tests/routes/books/book/annotation/AnnotationListPage.test.tsx
tests/routes/import/PersonalNotePage.test.tsx
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});


thinking
**Noting untracked file and test mention**
codex
Implemented and committed on `feat/story-016-named-categories`:

Commit: `2d4e99f`  
Message: `feat(story-016): migrate annotation categories to settings-driven names`

Changed files:
- `src/config/annotation-categories.ts`
- `src/data/models/annotations.ts`
- `src/data/utils/metadataSerializer.ts`
- `src/settings.ts`
- `src/ui/components/annotation-display-list.tsx`
- `src/ui/components/category-filter.tsx`
- `src/ui/routes/import/personal-note.tsx`
- `src/ui/routes/import/useAnnotationEditor.ts`
- `src/utils/annotation-filters.ts`
- `tests/api.test.ts`
- `tests/metadataSerializer.test.ts`
- `tests/models/annotations.test.ts`
- `tests/routes/books/book/annotation/AnnotationListPage.test.tsx`
- `tests/routes/import/PersonalNotePage.test.tsx`

Tests and verification run:
- `npm test -- --runInBand tests/metadataSerializer.test.ts` ✅
- `npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx` ✅
- `npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx` ✅
- `npm test -- --runInBand tests/models/annotations.test.ts` ✅
- `npm test -- --runInBand tests/api.test.ts` ✅
- `npm test -- --runInBand` ✅
- `OBSIDIAN_PLUGIN_DIR=. npm run build` ✅

Deviations from scope:
- `docs/plans/STORY-016-named-categories-settings-config.md` and `docs/plans/STORY-016-test-contract.md` do not exist in this worktree; executed against the exact scope/contract content you provided in your message.
- `scripts/story-catalog.sh check` and `scripts/lint-docs.sh` are missing in this repository (`No such file or directory`), so those two gates could not be executed.
- Build generated untracked `main.js` (left uncommitted).
file update:
diff --git a/src/config/annotation-categories.ts b/src/config/annotation-categories.ts
index fa7e42e1e22b1d11ef51562df7ff968ebc1556ad..669e043dcd802ad78c4ca2dc321f96b7599b8bc1
--- a/src/config/annotation-categories.ts
+++ b/src/config/annotation-categories.ts
@@ -1,10 +1,28 @@
 import { Icon } from "src/types/obsidian-icons";
 
-export const ANNOTATION_CATEGORY_ICONS: Icon[] = [
-    "lightbulb",
-    "quote",
-    "whole-word",
-    "sticky-note",
-    "star",
-    "asterisk"
+export interface CategoryConfig {
+    name: string;
+    icon: Icon;
+}
+
+export const DEFAULT_ANNOTATION_CATEGORIES: CategoryConfig[] = [
+    { name: "insight", icon: "lightbulb" },
+    { name: "quote", icon: "quote" },
+    { name: "vocabulary", icon: "whole-word" },
+    { name: "note", icon: "sticky-note" },
+    { name: "important", icon: "star" },
+    { name: "other", icon: "asterisk" },
 ];
+
+export const ANNOTATION_CATEGORY_ICONS: Icon[] = DEFAULT_ANNOTATION_CATEGORIES.map(
+    (category) => category.icon
+);
+
+export function resolveAnnotationCategories(
+    categories?: CategoryConfig[] | null
+): CategoryConfig[] {
+    if (!categories || categories.length === 0) {
+        return DEFAULT_ANNOTATION_CATEGORIES;
+    }
+    return categories.filter((category) => category.name && category.icon);
+}
diff --git a/src/data/models/annotations.ts b/src/data/models/annotations.ts
index b9f0341ef4e656bc8898a4001e4209f4471c6bc3..a14cb29e8d94b9663929b4fb15692c526697a5bc
--- a/src/data/models/annotations.ts
+++ b/src/data/models/annotations.ts
@@ -10,7 +10,7 @@
     hasFlashcards?: boolean;
     flashcardCount?: number;
     // Metadata fields
-    category?:      number;
+    category?:      string;
     deleted?:       boolean;
     personalNote?:  string;
     origin?:        string;
diff --git a/src/data/utils/metadataSerializer.ts b/src/data/utils/metadataSerializer.ts
index 2a74f7fd69f5858e78d2c7bd3969496248768fc8..9ff085a348ccf58a87f69f05f632c6a1fbdcfb06
--- a/src/data/utils/metadataSerializer.ts
+++ b/src/data/utils/metadataSerializer.ts
@@ -2,7 +2,7 @@
     original_color?: string;
     location?: string;
     timestamp?: string;
-    category?: number;
+    category?: string;
     deleted?: boolean;
     personal_note?: string;
     origin?: string;
@@ -47,7 +47,9 @@
                 metadata.timestamp = value;
                 break;
             case "category":
-                metadata.category = parseInt(value, 10);
+                if (!/^-?\d+$/.test(value)) {
+                    metadata.category = value;
+                }
                 break;
             case "deleted":
                 metadata.deleted = value === "true";
diff --git a/src/settings.ts b/src/settings.ts
index c4a02883c838f4984cd2718590459ceec734ac8d..a165fa91302fe343e8473bbf8c5b7443ece19dc7
--- a/src/settings.ts
+++ b/src/settings.ts
@@ -3,6 +3,7 @@
 
 import type SRPlugin from "src/main";
 import { t } from "src/lang/helpers";
+import { CategoryConfig, DEFAULT_ANNOTATION_CATEGORIES } from "src/config/annotation-categories";
 
 export interface SRSettings {
     // flashcards
@@ -41,6 +42,7 @@
     maxLinkFactor: number;
     // logging
     showDebugMessages: boolean;
+    annotationCategories: CategoryConfig[];
 }
 
 export const DEFAULT_SETTINGS: SRSettings = {
@@ -79,7 +81,8 @@
     maximumInterval: 36525,
     maxLinkFactor: 1.0,
     // logging
-    showDebugMessages: false
+    showDebugMessages: false,
+    annotationCategories: [...DEFAULT_ANNOTATION_CATEGORIES],
 };
 
 // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/Settings.ts
diff --git a/src/ui/components/annotation-display-list.tsx b/src/ui/components/annotation-display-list.tsx
index 8904bf17dac2ef1c96e2c1d35e581cbeeee58d74..9420f11523bd2a9599633d3ea9a925eb8c7d7755
--- a/src/ui/components/annotation-display-list.tsx
+++ b/src/ui/components/annotation-display-list.tsx
@@ -4,11 +4,12 @@
 import { getFilteredAnnotations } from "src/utils/annotation-filters";
 import { integerToRGBA } from "src/utils/utils";
 import { CategoryFilter } from "src/ui/components/category-filter";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
+import { resolveAnnotationCategories } from "src/config/annotation-categories";
 import {
     AnnotationListViewPolicy,
     AnnotationMainFilter,
 } from "src/data/models/sourceCapabilities";
+import { getPluginContext } from "src/application/plugin-context";
 
 interface AnnotationListItemProps {
     annotation: annotation;
@@ -84,7 +85,9 @@
         viewPolicy,
     } = props;
     const effectiveFilter = viewPolicy.enforcedMainFilter ?? filter;
-    const [activeCategoryFilter, setActiveCategoryFilter] = useState<number | null>(null);
+    const [activeCategoryFilter, setActiveCategoryFilter] = useState<string | null>(null);
+    const plugin = getPluginContext() as any;
+    const categories = resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories);
 
     // todo: why do we use useMemo here? Seems unnecessary especially when we have a direct API and things are all local.
     // we don't need to cache anything, so consider removing
@@ -159,6 +162,7 @@
                 <div style={{ marginBottom: '1rem' }}>
                     {viewPolicy.showCategoryFilter && effectiveFilter === 'processed' && (
                         <CategoryFilter
+                            categories={categories}
                             selectedCategory={activeCategoryFilter}
                             onCategorySelect={setActiveCategoryFilter}
                         />
diff --git a/src/ui/components/category-filter.tsx b/src/ui/components/category-filter.tsx
index b25ef879694e2b58c74361794cf83cd3a1e015ef..3816eace8ba5ff43e5a57ce6fc78b5f274313026
--- a/src/ui/components/category-filter.tsx
+++ b/src/ui/components/category-filter.tsx
@@ -1,55 +1,55 @@
-import React, { useEffect, useRef } from "react";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { ANNOTATION_CATEGORY_ICONS } from "src/config/annotation-categories";
-import { Icon } from "src/types/obsidian-icons";
-
-interface CategoryFilterProps {
-    selectedCategory: number | null;
-    onCategorySelect: (category: number | null) => void;
-}
-
-export function CategoryFilter({ categories, selectedCategory, onCategorySelect }: Props) {
-    const iconRefs = ANNOTATION_CATEGORY_ICONS.map(() => useRef<HTMLDivElement>(null));
-    // const clearFilterRef = useRef<HTMLDivElement>(null); // No longer needed
-
-    useEffect(() => {
-        ANNOTATION_CATEGORY_ICONS.forEach((iconName, i) => {
-            if (iconRefs[i].current) {
-                setIcon(iconRefs[i].current, iconName);
-            }
-        });
-        // if (clearFilterRef.current) { // No longer needed
-        //     setIcon(clearFilterRef.current, "circle-slash"); // Icon for clearing the filter
-        // }
-    }, []);
-
-    const handleCategoryClick = (categoryIndex: number) => {
-        if (selectedCategory === categoryIndex) {
-            onCategorySelect(null);
-        } else {
-            onCategorySelect(categoryIndex);
-        }
-    };
-
-    return (
-        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
-            {ANNOTATION_CATEGORY_ICONS.map((_, i) => (
-                <div
-                    key={i}
-                    className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                    onClick={() => handleCategoryClick(i)}
-                    style={{
-                        padding: "8px",
-                        border: "1px solid",
-                        borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                        borderRadius: "4px",
-                        backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                    }}
-                >
-                    <div ref={iconRefs[i]} />
-                </div>
-            ))}
-            {/* The clear category button is removed as per the new toggle behavior */}
-        </div>
-    );
-}
+import React, { useEffect, useRef } from "react";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import type { CategoryConfig } from "src/config/annotation-categories";
+
+interface CategoryFilterProps {
+    categories: CategoryConfig[];
+    selectedCategory: string | null;
+    onCategorySelect: (category: string | null) => void;
+}
+
+export function CategoryFilter({
+    categories,
+    selectedCategory,
+    onCategorySelect,
+}: CategoryFilterProps) {
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
+
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+    }, [categories]);
+
+    const handleCategoryClick = (categoryName: string) => {
+        if (selectedCategory === categoryName) {
+            onCategorySelect(null);
+        } else {
+            onCategorySelect(categoryName);
+        }
+    };
+
+    return (
+        <div className="sr-category-buttons" style={{ display: "flex", gap: "0.5rem" }}>
+            {categories.map((category, i) => (
+                <div
+                    key={category.name}
+                    className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                    onClick={() => handleCategoryClick(category.name)}
+                    style={{
+                        padding: "8px",
+                        border: "1px solid",
+                        borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                        borderRadius: "4px",
+                        backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                    }}
+                >
+                    <div ref={(element) => { iconRefs.current[i] = element; }} />
+                </div>
+            ))}
+        </div>
+    );
+}
diff --git a/src/ui/routes/import/personal-note.tsx b/src/ui/routes/import/personal-note.tsx
index 860b2d85bcc3faff04f0b9b17a6dd715c7b9c916..0e4398f85d438a181c03aa50bc56ca7841c1cead
--- a/src/ui/routes/import/personal-note.tsx
+++ b/src/ui/routes/import/personal-note.tsx
@@ -1,13 +1,17 @@
-import React, { useEffect, useRef } from "react";
-import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
-import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
-import { setIcon } from "src/infrastructure/obsidian-facade";
-import { type Icon } from "src/types/obsidian-icons";
-import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
-import { getAnnotationById } from "src/api";
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
-import NavigationControl from "src/ui/components/NavigationControl";
-import { pathGenerator } from "src/utils/path-generators";
+import React, { useEffect, useRef, useState } from "react";
+import { useLoaderData, useLocation, useNavigate, useParams } from "react-router-dom";
+import { HighlightBlock, NoteBlock } from "src/ui/components/display-blocks";
+import { setIcon } from "src/infrastructure/obsidian-facade";
+import { useAnnotationEditor } from "src/ui/routes/import/useAnnotationEditor";
+import { getAnnotationById } from "src/api";
+import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import NavigationControl from "src/ui/components/NavigationControl";
+import { pathGenerator } from "src/utils/path-generators";
+import {
+    type CategoryConfig,
+    resolveAnnotationCategories,
+} from "src/config/annotation-categories";
+import { getPluginContext } from "src/application/plugin-context";
 
 export async function personalNoteLoader({ params }: any) {
     const { bookId, annotationId } = params;
@@ -15,8 +19,8 @@
     return { annotation, bookId };
 }
 
-export function PersonalNotePage() {
-    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
+export function PersonalNotePage() {
+    const { annotation, bookId } = useLoaderData() as { annotation: any, bookId: string };
     const navigate = useNavigate();
     const location = useLocation();
     const params = useParams();
@@ -32,15 +36,15 @@
         navigateBack,
     } = useAnnotationEditor(annotation, bookId);
 
-    const deleteButtonRef = useRef<HTMLDivElement>(null);
-    const iconRefs = [
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-        useRef<HTMLDivElement>(null),
-    ];
+    const plugin = getPluginContext() as any;
+    const [categories, setCategories] = useState<CategoryConfig[]>(() =>
+        resolveAnnotationCategories(plugin?.data?.settings?.annotationCategories)
+    );
+    const [newCategoryName, setNewCategoryName] = useState("");
+    const [newCategoryError, setNewCategoryError] = useState("");
+
+    const deleteButtonRef = useRef<HTMLDivElement>(null);
+    const iconRefs = useRef<Array<HTMLDivElement | null>>([]);
 
     const previousAnnotationId = getPreviousAnnotationIdForSection(bookId, params.sectionId, annotation.id);
     const nextAnnotationId = getNextAnnotationIdForSection(bookId, params.sectionId, annotation.id);
@@ -54,17 +58,42 @@
     };
 
 
-    useEffect(() => {
-        const icons: Icon[] = ["lightbulb", "quote", "whole-word", "sticky-note", "star", "asterisk"];
-        iconRefs.forEach((ref, i) => {
-            if (ref.current) {
-                setIcon(ref.current, icons[i]);
-            }
-        });
-        if (deleteButtonRef.current) {
-            setIcon(deleteButtonRef.current, "trash");
-        }
-    }, []);
+    useEffect(() => {
+        categories.forEach((category, i) => {
+            const iconRef = iconRefs.current[i];
+            if (iconRef) {
+                setIcon(iconRef, category.icon);
+            }
+        });
+        if (deleteButtonRef.current) {
+            setIcon(deleteButtonRef.current, "trash");
+        }
+    }, [categories]);
+
+    const handleAddCategory = async () => {
+        const trimmed = newCategoryName.trim();
+        if (!trimmed) {
+            setNewCategoryError("Category name is required.");
+            return;
+        }
+        if (categories.some((category) => category.name.toLowerCase() === trimmed.toLowerCase())) {
+            setNewCategoryError("Category already exists.");
+            return;
+        }
+
+        const createdCategory = { name: trimmed, icon: "asterisk" as const };
+        const nextCategories = [...categories, createdCategory];
+        setCategories(nextCategories);
+        setNewCategoryName("");
+        setNewCategoryError("");
+
+        if (plugin?.data?.settings) {
+            plugin.data.settings.annotationCategories = nextCategories;
+            if (typeof plugin.savePluginData === "function") {
+                await plugin.savePluginData();
+            }
+        }
+    };
 
     return (
         <div className="sr-personal-note-page">
@@ -119,24 +148,37 @@
                 />
             </div>
 
-            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
-                {iconRefs.map((ref, i) => (
-                    <div
-                        key={i}
-                        className={`sr-category-button is-clickable ${selectedCategory === i ? "is-active" : ""}`}
-                        onClick={() => handleCategoryClick(i)}
-                        style={{
-                            padding: "10px",
-                            border: "2px solid",
-                            borderColor: selectedCategory === i ? "var(--interactive-accent)" : "var(--background-modifier-border)",
-                            borderRadius: "4px",
-                            backgroundColor: selectedCategory === i ? "var(--background-modifier-hover)" : "transparent"
-                        }}
-                    >
-                        <div ref={ref} />
-                    </div>
-                ))}
-            </div>
+            <div className="sr-category-buttons" style={{ display: "flex", justifyContent: "space-around", marginTop: "20px" }}>
+                {categories.map((category, i) => (
+                    <div
+                        key={category.name}
+                        className={`sr-category-button is-clickable ${selectedCategory === category.name ? "is-active" : ""}`}
+                        onClick={() => handleCategoryClick(category.name)}
+                        style={{
+                            padding: "10px",
+                            border: "2px solid",
+                            borderColor: selectedCategory === category.name ? "var(--interactive-accent)" : "var(--background-modifier-border)",
+                            borderRadius: "4px",
+                            backgroundColor: selectedCategory === category.name ? "var(--background-modifier-hover)" : "transparent"
+                        }}
+                    >
+                        <div ref={(element) => { iconRefs.current[i] = element; }} />
+                    </div>
+                ))}
+            </div>
+
+            <div style={{ marginTop: "12px", display: "flex", gap: "8px", alignItems: "center" }}>
+                <input
+                    type="text"
+                    placeholder="New category name"
+                    value={newCategoryName}
+                    onChange={(event) => setNewCategoryName(event.target.value)}
+                />
+                <button onClick={handleAddCategory}>Add category</button>
+            </div>
+            {newCategoryError && (
+                <div style={{ marginTop: "8px", color: "var(--text-error)" }}>{newCategoryError}</div>
+            )}
 
             <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
                 <button className="mod-cta" onClick={handleSave}>Save</button>
diff --git a/src/ui/routes/import/useAnnotationEditor.ts b/src/ui/routes/import/useAnnotationEditor.ts
index f46e8ebbdfb7ef9650669ce499e1fc9e7c580025..a268c0e8828158b6b2b12ee0b7ddab5d22d55004
--- a/src/ui/routes/import/useAnnotationEditor.ts
+++ b/src/ui/routes/import/useAnnotationEditor.ts
@@ -8,13 +8,13 @@
     highlight: string;
     note: string;
     personalNote?: string;
-    category?: number | null;
+    category?: string | null;
     originalColor?: number;
 }
 
 export function useAnnotationEditor(initialAnnotation: Annotation, bookId: string) {
     const [personalNote, setPersonalNote] = useState(initialAnnotation.personalNote || "");
-    const [selectedCategory, setSelectedCategory] = useState<number | null>(
+    const [selectedCategory, setSelectedCategory] = useState<string | null>(
         initialAnnotation.category !== undefined ? initialAnnotation.category : null
     );
     const navigate = useNavigate();
@@ -26,8 +26,8 @@
         return null;
     }, [initialAnnotation.originalColor]);
 
-    const handleCategoryClick = (index: number) => {
-        setSelectedCategory(selectedCategory === index ? null : index);
+    const handleCategoryClick = (categoryName: string) => {
+        setSelectedCategory(selectedCategory === categoryName ? null : categoryName);
     };
 
     const save = async () => {
diff --git a/src/utils/annotation-filters.ts b/src/utils/annotation-filters.ts
index 564ef974530eb1d7081535355d19d1ba915665af..3430ffac782b20737bd5d67dbbe6d5ac3955ae2b
--- a/src/utils/annotation-filters.ts
+++ b/src/utils/annotation-filters.ts
@@ -4,12 +4,12 @@
 
 export interface AnnotationFilter {
     mainFilter?: AnnotationMainFilter;
-    categoryFilter?: number | null;
+    categoryFilter?: string | null;
     colorFilter?: string | null;
 }
 
 export interface FilterableAnnotation {
-    category?: number | null;
+    category?: string | null;
     deleted?: boolean;
     originalColor?: string;
 }
@@ -43,7 +43,7 @@
 export function getFilteredAnnotations(
     annotations: annotation[],
     mainFilter: AnnotationMainFilter,
-    categoryFilter: number | null,
+    categoryFilter: string | null,
     colorFilter: string | null
 ): annotation[] {
     return annotations.filter((ann) =>
diff --git a/tests/api.test.ts b/tests/api.test.ts
index 64ae1f2f81355c8ef75bdb518b65838f47ae9401..f6090e6c589afbef7b79abb0d661021b8fbb97bf
--- a/tests/api.test.ts
+++ b/tests/api.test.ts
@@ -897,7 +897,7 @@
                                 id: "ann-2",
                                 highlight: "A2",
                                 note: "",
-                                category: 1,
+                                category: "insight",
                                 originalColor: "2",
                                 deleted: false,
                             },
@@ -915,7 +915,7 @@
                                 id: "ann-4",
                                 highlight: "A4",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -932,7 +932,7 @@
                                 id: "ann-5",
                                 highlight: "A5",
                                 note: "",
-                                category: 2,
+                                category: "quote",
                                 originalColor: "3",
                                 deleted: false,
                             },
@@ -964,7 +964,7 @@
                 id: "ann-2",
                 highlight: "A2",
                 note: "",
-                category: 1,
+                category: "insight",
                 originalColor: "2",
                 deleted: false,
                 calloutType: "",
@@ -984,7 +984,7 @@
                 id: "ann-4",
                 highlight: "A4",
                 note: "",
-                category: 2,
+                category: "quote",
                 originalColor: "3",
                 deleted: false,
                 calloutType: "",
@@ -1007,13 +1007,13 @@
     test("category filter narrows processed navigation and stops at section boundary", () => {
         const nextCategory2 = getNextAnnotationId(bookId, "ann-2", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(nextCategory2).toBe("ann-4");
 
         const noNextInSection = getNextAnnotationId(bookId, "ann-4", sectionId, {
             mainFilter: "processed",
-            categoryFilter: 2,
+            categoryFilter: "quote",
         });
         expect(noNextInSection).toBeNull();
     });
@@ -1037,7 +1037,7 @@
         const filters = [
             { mainFilter: "all" as const },
             { mainFilter: "processed" as const },
-            { mainFilter: "processed" as const, categoryFilter: 2 },
+            { mainFilter: "processed" as const, categoryFilter: "quote" },
             { mainFilter: "unprocessed" as const },
             { mainFilter: "unprocessed" as const, colorFilter: "2" },
         ];
diff --git a/tests/metadataSerializer.test.ts b/tests/metadataSerializer.test.ts
index 58c2af03c6447550052d45320af4e138a13f6dbc..0d018277a981ac4c644c15c723465167bf47d2da
--- a/tests/metadataSerializer.test.ts
+++ b/tests/metadataSerializer.test.ts
@@ -1,7 +1,15 @@
-import { serializeMetadata } from "src/data/utils/metadataSerializer";
+import { deserializeMetadata, serializeMetadata } from "src/data/utils/metadataSerializer";
+
+describe("metadataSerializer", () => {
+    test("serializes string category names in metadata", () => {
+        expect(serializeMetadata({ category: "insight" as any })).toContain("category: insight");
+    });
+
+    test("ignores legacy numeric category metadata values", () => {
+        expect(deserializeMetadata("category: 2")).toEqual({});
+    });
 
-describe("serializeMetadata", () => {
     test("should serialize only deleted: true", () => {
-        expect(serializeMetadata({ deleted: true })).toMatchInlineSnapshot(`"deleted: true"`);
+        expect(serializeMetadata({ deleted: true })).toBe("deleted: true");
     });
 });
diff --git a/tests/models/annotations.test.ts b/tests/models/annotations.test.ts
index 48ae0c130e3f4df81f2b39448e0d96423871a087..b60be4722a86764c946df9f183aae0dfb72f4135
--- a/tests/models/annotations.test.ts
+++ b/tests/models/annotations.test.ts
@@ -17,7 +17,7 @@
 
 describe("isAnnotationProcessed", () => {
     test("should return true if annotation has a category", () => {
-        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: 1 };
+        const annotation = { type: "annotation", id: "1", calloutType: "note", highlight: "hi", note: "", category: "insight" };
         expect(isAnnotationProcessed(annotation)).toBe(true);
     });
 
diff --git a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
index 0db07494aaefbaaa225cf6b02367ee7813df3869..aec027131a864e0bf87152e8c326ebbd468a5066
--- a/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
+++ b/tests/routes/books/book/annotation/AnnotationListPage.test.tsx
@@ -34,7 +34,7 @@
             calloutType: "text",
             highlight: "Processed highlight",
             note: "",
-            category: 2,
+            category: "quote",
         },
     ],
 };
@@ -122,6 +122,28 @@
         });
     });
 
+    test("MoonReader card creation category filter uses string categories", async () => {
+        useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
+        useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: moonreaderCapabilities });
+
+        const { container } = render(
+            <MemoryRouter>
+                <AnnotationListPage />
+            </MemoryRouter>
+        );
+
+        const firstCategoryButton = container.querySelector(".sr-category-button") as HTMLElement;
+        fireEvent.click(firstCategoryButton);
+
+        await waitFor(() => {
+            expect(getNavigationFilter()).toEqual({
+                mainFilter: "processed",
+                categoryFilter: "insight",
+                colorFilter: null,
+            });
+        });
+    });
+
     test("direct-markdown card creation remains all/no-processing", async () => {
         useLocationMock.mockReturnValue({ pathname: "/books/1/chapters/2/annotations" });
         useLoaderDataMock.mockReturnValue({ ...chapterData, sourceCapabilities: markdownCapabilities });
@@ -179,7 +201,7 @@
         await waitFor(() => {
             expect(getNavigationFilter()).toEqual({
                 mainFilter: "processed",
-                categoryFilter: 0,
+                categoryFilter: "insight",
                 colorFilter: null,
             });
         });
diff --git a/tests/routes/import/PersonalNotePage.test.tsx b/tests/routes/import/PersonalNotePage.test.tsx
index eafbe012b6db179a82fd9fa13ff569c0ce8e92d9..730f76a4fb5a8bffa5b1a6fea7ae199e1409a09a
--- a/tests/routes/import/PersonalNotePage.test.tsx
+++ b/tests/routes/import/PersonalNotePage.test.tsx
@@ -73,7 +73,10 @@
     getNextAnnotationIdForSection: jest.fn(),
 }));
 
-import { getNextAnnotationIdForSection, getPreviousAnnotationIdForSection } from "src/ui/routes/books/api";
+import {
+    getNextAnnotationIdForSection,
+    getPreviousAnnotationIdForSection,
+} from "src/ui/routes/books/api";
 
 // Mock Obsidian setIcon
 jest.mock("src/infrastructure/obsidian-facade", () => ({
@@ -93,11 +96,12 @@
     const mockNavigate = jest.fn();
     let mockBookId: string;
     let mockAnnotationId: string;
+    let mockPlugin: any;
     let confirmSpy: jest.SpyInstance;
 
     beforeEach(async () => {
-        const plugin = await initializePlugin();
-        const book = plugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
+        mockPlugin = await initializePlugin();
+        const book = mockPlugin.annotationsNoteIndex.getAllAnnotationsNotes()[0];
         mockBookId = book.id;
         mockAnnotationId = book.annotations()[0].id;
 
@@ -219,7 +223,7 @@
             highlight: "This is a test highlight.",
             note: "This is a test note.",
             personalNote: "My personal thoughts on this highlight.",
-            category: 2,
+            category: "vocabulary",
             originalColor: 16711680, // Red color
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -350,6 +354,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -495,6 +511,18 @@
                   </div>
                 </div>
                 <div
+                  style="margin-top: 12px; display: flex; gap: 8px; align-items: center;"
+                >
+                  <input
+                    placeholder="New category name"
+                    type="text"
+                    value=""
+                  />
+                  <button>
+                    Add category
+                  </button>
+                </div>
+                <div
                   style="margin-top: 20px; display: flex; gap: 10px;"
                 >
                   <button
@@ -511,6 +539,31 @@
         `);
     });
 
+    it("category buttons render from configured settings categories", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+            { name: "memory", icon: "star" },
+        ];
+        const mockAnnotation = {
+            id: mockAnnotationId,
+            highlight: "Highlight",
+            note: "Note",
+            personalNote: "",
+            category: undefined,
+            originalColor: undefined,
+        };
+        useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
+
+        const { container } = render(
+            <MemoryRouter>
+                <PersonalNotePage />
+            </MemoryRouter>
+        );
+
+        expect(container.querySelectorAll(".sr-category-button")).toHaveLength(3);
+    });
+
     it("should handle category click and update state", async () => {
         const mockAnnotation = {
             id: mockAnnotationId,
@@ -541,13 +594,17 @@
         });
     });
 
-    it("should call updateAnnotationMetadata and navigate on save", async () => {
+    it("selecting category saves category name string", async () => {
+        mockPlugin.data.settings.annotationCategories = [
+            { name: "insight", icon: "lightbulb" },
+            { name: "quote", icon: "quote" },
+        ];
         const mockAnnotation = {
             id: mockAnnotationId,
             highlight: "Highlight",
             note: "Note",
             personalNote: "Initial note",
-            category: 1,
+            category: "quote",
             originalColor: undefined,
         };
         useLoaderDataMock.mockReturnValue({ annotation: mockAnnotation, bookId: mockBookId });
@@ -571,7 +628,7 @@
             expect(updateAnnotationMetadataMock).toHaveBeenCalledWith(
                 mockBookId,
                 mockAnnotationId,
-                { personalNote: "New note", category: 0 }
+                { personalNote: "New note", category: "insight" }
             );
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
@@ -605,4 +662,4 @@
             expect(mockNavigate).toHaveBeenCalledWith(-1);
         });
     });
-});
\ No newline at end of file
+});

tokens used
153,526
Implemented and committed on `feat/story-016-named-categories`:

Commit: `2d4e99f`  
Message: `feat(story-016): migrate annotation categories to settings-driven names`

Changed files:
- `src/config/annotation-categories.ts`
- `src/data/models/annotations.ts`
- `src/data/utils/metadataSerializer.ts`
- `src/settings.ts`
- `src/ui/components/annotation-display-list.tsx`
- `src/ui/components/category-filter.tsx`
- `src/ui/routes/import/personal-note.tsx`
- `src/ui/routes/import/useAnnotationEditor.ts`
- `src/utils/annotation-filters.ts`
- `tests/api.test.ts`
- `tests/metadataSerializer.test.ts`
- `tests/models/annotations.test.ts`
- `tests/routes/books/book/annotation/AnnotationListPage.test.tsx`
- `tests/routes/import/PersonalNotePage.test.tsx`

Tests and verification run:
- `npm test -- --runInBand tests/metadataSerializer.test.ts` ✅
- `npm test -- --runInBand tests/routes/import/PersonalNotePage.test.tsx` ✅
- `npm test -- --runInBand tests/routes/books/book/annotation/AnnotationListPage.test.tsx` ✅
- `npm test -- --runInBand tests/models/annotations.test.ts` ✅
- `npm test -- --runInBand tests/api.test.ts` ✅
- `npm test -- --runInBand` ✅
- `OBSIDIAN_PLUGIN_DIR=. npm run build` ✅

Deviations from scope:
- `docs/plans/STORY-016-named-categories-settings-config.md` and `docs/plans/STORY-016-test-contract.md` do not exist in this worktree; executed against the exact scope/contract content you provided in your message.
- `scripts/story-catalog.sh check` and `scripts/lint-docs.sh` are missing in this repository (`No such file or directory`), so those two gates could not be executed.
- Build generated untracked `main.js` (left uncommitted).

Script done on 2026-02-20 19:38:39-08:00 [COMMAND_EXIT_CODE="0"]
