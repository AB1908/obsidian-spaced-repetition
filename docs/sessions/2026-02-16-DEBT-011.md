# Session: DEBT-011 — 2026-02-16

## Story
[DEBT-011](../stories/DEBT-011-book-metaphor-clippings.md)

## Goal
Design a navigation model that works for both MoonReader books and markdown clippings. Resolve remaining DEBT-011 acceptance criteria.

## Findings

### Behavior divergence inventory
Identified 5 lifecycle points where MoonReader and markdown sources diverge: import, navigation, deck creation, rendering, mutation confirmation. Only import is handled by the strategy pattern; the other 4 use scattered conditionals in `api.ts`.

### Strategy pattern is underused
`ISourceStrategy` only has `sync()` and `extract()`. `MarkdownSourceStrategy` and `Source` class exist but are dead code — never integrated into `AnnotationsNote`.

### `updateAnnotation()` is broken for paragraphs
Calls `renderAnnotation()` which outputs MoonReader callout format. Paragraphs get transformed via `transform()` to masquerade as annotations, but the rendered markdown is wrong.

### `bookSections` god-array
`(Heading | annotation | paragraph)[]` with duck-typed guards (`highlight !== undefined`, `wasIdPresent !== undefined`). No discriminator field makes pattern matching fragile and error-prone.

### UI components are already generic
Despite book-themed variable names, ChapterList, AnnotationListPage, and annotation-with-outlet components consume abstract data shapes (`{ id, name }[]` for sections, `{ id, title, annotations }` for items). No source-type conditionals in components.

## Decisions

1. **Composition over inheritance** — confirmed ADR-018's choice. Expand strategy interface rather than creating separate source classes.
2. **Discriminated union first** — add `type: 'heading' | 'annotation' | 'paragraph'` before expanding strategies, for cleaner implementation.
3. **4 sequential PRs** — each self-contained, each removes one category of conditionals from api.ts.
4. **Defer renames** — `AnnotationsNote` → `SourceNote`, `bookSections` → `sections`, route paths. Keep PRs focused on structural changes.
5. **Clippings do NOT need their own routes** — components are already generic.

## Artifacts Created
- Plan: `docs/plans/DEBT-011-source-model-seam-repair.md`
- Stories: DEBT-016, DEBT-017, DEBT-018 (meta-workflow improvements identified during analysis)

## PR 1 Execution Notes

Completed: discriminated union for sections. Key decision during implementation: renamed `annotation.type` (MoonReader callout type, dead field) to `calloutType` to free `type` for the discriminator. This makes `type` first-class — consumers can filter with `section.type === 'heading'` directly without importing guard functions.

## Workflow Improvement: Incremental Commit Discipline

**Problem observed:** We did all changes first, then committed as one batch. This means we had an unstable build during the entire implementation — no safe revert points.

**Desired workflow:** Plan execution as a sequence of incremental, independently-stable commits upfront. Each commit should leave the build green. For this PR, the ideal commit sequence would have been:

1. `refactor(model): rename annotation.type to calloutType` — rename only, all tests pass
2. `refactor(model): add type discriminator to section types` — add `type` field to interfaces/classes and `bookSections()`, update test fixtures, all tests pass
3. `refactor(model): rewrite type guards to use discriminator` — replace duck-typing with `section.type ===` checks, all tests pass

**Proposed practice for future work:**
- During planning, predict the commit sequence (not just the file changes)
- Each predicted commit should be independently testable (`npm test` green)
- After execution, review: did we follow the predicted path? Where did we deviate? What debt did we discover?
- This enables: quick reverts, stable builds on every commit in main, smaller code review surface per commit

**Meta-observation:** This is a workflow improvement story candidate — formalizing "commit-first planning" as part of the session start workflow.

## Next Steps
- Commit PR 1 changes
- Implement PR 2 (wire strategy into AnnotationsNote + getNavigableSections)
