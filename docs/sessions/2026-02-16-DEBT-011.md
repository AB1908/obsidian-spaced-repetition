# Session: DEBT-011 — 2026-02-16

**Agent:** Claude Code (Opus 4.6) — worktree `refactor-discriminated-union`

## Story
[DEBT-011](../stories/DEBT-011-book-metaphor-clippings.md)

## Goal
Design a navigation model that works for both MoonReader books and markdown clippings. Resolve remaining DEBT-011 acceptance criteria.

## Findings

### Behavior divergence inventory
Identified 5 lifecycle points where MoonReader and markdown sources diverge: import, navigation, deck creation, rendering, mutation confirmation. Only import is handled by the strategy pattern; the other 4 use scattered conditionals in `api.ts`.

### Strategy pattern is underused
`ISourceStrategy` only has `sync()` and `extract()`. `MarkdownSourceStrategy` and `Source` class exist but are dead code — never integrated into `AnnotationsNote`.

### `updateAnnotation()` is broken for paragraphs
Calls `renderAnnotation()` which outputs MoonReader callout format. Paragraphs get transformed via `transform()` to masquerade as annotations, but the rendered markdown is wrong.

### `bookSections` god-array
`(Heading | annotation | paragraph)[]` with duck-typed guards (`highlight !== undefined`, `wasIdPresent !== undefined`). No discriminator field makes pattern matching fragile and error-prone.

### UI components are already generic
Despite book-themed variable names, ChapterList, AnnotationListPage, and annotation-with-outlet components consume abstract data shapes (`{ id, name }[]` for sections, `{ id, title, annotations }` for items). No source-type conditionals in components.

## Decisions

1. **Composition over inheritance** — confirmed ADR-018's choice. Expand strategy interface rather than creating separate source classes.
2. **Discriminated union first** — add `type: 'heading' | 'annotation' | 'paragraph'` before expanding strategies, for cleaner implementation.
3. **4 sequential PRs** — each self-contained, each removes one category of conditionals from api.ts.
4. **Defer renames** — `AnnotationsNote` → `SourceNote`, `bookSections` → `sections`, route paths. Keep PRs focused on structural changes.
5. **Clippings do NOT need their own routes** — components are already generic.

## Artifacts Created
- Plan: `docs/plans/DEBT-011-source-model-seam-repair.md`
- Stories: DEBT-016, DEBT-017, DEBT-018 (meta-workflow improvements identified during analysis)

## PR 1 Execution Notes

Completed: discriminated union for sections. Key decision during implementation: renamed `annotation.type` (MoonReader callout type, dead field) to `calloutType` to free `type` for the discriminator. This makes `type` first-class — consumers can filter with `section.type === 'heading'` directly without importing guard functions.

## Workflow Improvement: Incremental Commit Discipline

**Problem observed:** We did all changes first, then committed as one batch. This means we had an unstable build during the entire implementation — no safe revert points.

**Desired workflow:** Plan execution as a sequence of incremental, independently-stable commits upfront. Each commit should leave the build green. For this PR, the ideal commit sequence would have been:

1. `refactor(model): rename annotation.type to calloutType` — rename only, all tests pass
2. `refactor(model): add type discriminator to section types` — add `type` field to interfaces/classes and `bookSections()`, update test fixtures, all tests pass
3. `refactor(model): rewrite type guards to use discriminator` — replace duck-typing with `section.type ===` checks, all tests pass

**Proposed practice for future work:**
- During planning, predict the commit sequence (not just the file changes)
- Each predicted commit should be independently testable (`npm test` green)
- After execution, review: did we follow the predicted path? Where did we deviate? What debt did we discover?
- This enables: quick reverts, stable builds on every commit in main, smaller code review surface per commit

**Meta-observation:** This is a workflow improvement story candidate — formalizing "commit-first planning" as part of the session start workflow.

## Workflow Improvement: Agent Attribution in Session Notes

**Problem:** Multiple agents (Claude Code, Gemini, etc.) work across different worktrees and stories. Session notes currently don't identify which agent produced them, making it hard to spot recurring themes per agent (e.g., does one agent consistently batch commits? does another over-plan?).

**Proposed convention:** Add an `Agent:` line to the session note header:
```
**Agent:** <tool> (<model>) — worktree `<branch-name>`
```

This enables:
- `grep -l "Agent: Claude Code" docs/sessions/` to find all Claude Code sessions
- Cross-agent theme analysis (e.g., "both agents flagged the same debt")
- Workflow retrospectives scoped to a specific agent's tendencies

## Workflow Improvement: Story ID in Commit Description, Not Subject

**Before:** `refactor(model): add discriminated union to section types [DEBT-001]`
**After:**
```
refactor(model): add discriminated union to section types

DEBT-001
```

Rationale: subject line stays clean and scannable in `git log --oneline`. Story ID is still grep-able via `git log --grep="DEBT-001"`. Aligns with "commits tell WHAT" — the story ID is context (WHY), belongs in body. Workflow guides (CLAUDE.md, workflow.md) should be updated to reflect this.

## Note: Squashing vs Green Builds

Squashing/rebasing could theoretically break the "green build on every commit" invariant. In practice, if every pre-squash commit is green and operations are order-preserving, the squashed result should also be green. Edge case: two commits that are individually green but interact badly when combined (unlikely with incremental refactors, more likely with parallel feature branches). Worth monitoring but not a blocker for adopting both practices together.

## Next Steps
- Implement PR 2 (wire strategy into AnnotationsNote + getNavigableSections)
